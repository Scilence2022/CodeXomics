<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAM Stack Overflow Fix Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 30px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .test-section h3 { color: #2980b9; margin-top: 0; }
        .button { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        .button:hover { background: #2980b9; }
        .button.danger { background: #e74c3c; }
        .button.danger:hover { background: #c0392b; }
        .result { margin: 10px 0; padding: 10px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; }
        .result.success { background: #d5f4e6; border: 1px solid #27ae60; color: #27ae60; }
        .result.error { background: #fdf2f2; border: 1px solid #e74c3c; color: #e74c3c; }
        .result.info { background: #e8f4fd; border: 1px solid #3498db; color: #2980b9; }
        .result.warning { background: #fff3cd; border: 1px solid #ffc107; color: #856404; }
        .progress { width: 100%; height: 20px; background: #f0f0f0; border-radius: 10px; margin: 10px 0; }
        .progress-bar { height: 100%; background: #3498db; border-radius: 10px; transition: width 0.3s; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß¨ BAM Stack Overflow Fix Test</h1>
            <p>Testing fixes for "Maximum call stack size exceeded" error with large BAM datasets</p>
        </div>

        <div class="test-section">
            <h3>Test 1: Memory-Efficient Statistics Calculation</h3>
            <p>Test the new chunked statistics calculation that prevents stack overflow</p>
            <button class="button" onclick="testStatisticsCalculation()">Test Statistics Fix</button>
            <div id="stats-results"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Early Sampling for Extreme Datasets</h3>
            <p>Test early sampling mechanism for datasets > 200k records</p>
            <button class="button" onclick="testEarlySampling()">Test Early Sampling</button>
            <div id="sampling-results"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: Memory-Efficient Chunked Processing</h3>
            <p>Test the improved chunked processing with better memory management</p>
            <button class="button" onclick="testChunkedProcessing()">Test Chunked Processing</button>
            <div id="chunked-results"></div>
        </div>

        <div class="test-section">
            <h3>Test 4: Extreme Dataset Simulation (316k records)</h3>
            <p>Simulate the exact scenario from user's error (316,372 records)</p>
            <button class="button danger" onclick="testExtremeDataset()">‚ö†Ô∏è Test Extreme Dataset</button>
            <div id="extreme-results"></div>
            <div class="progress" id="extreme-progress" style="display: none;">
                <div class="progress-bar" id="extreme-progress-bar"></div>
            </div>
        </div>
    </div>

    <script>
        function addResult(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const result = document.createElement('div');
            result.className = `result ${type}`;
            result.textContent = message;
            container.appendChild(result);
        }

        function updateProgress(progressBarId, percentage) {
            const progressBar = document.getElementById(progressBarId);
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        // Mock BAM record generator
        function generateMockBamRecords(count, startPos = 2791421, endPos = 2801422) {
            const records = [];
            for (let i = 0; i < count; i++) {
                const start = startPos + Math.floor(Math.random() * (endPos - startPos));
                records.push({
                    name: `LH00281:496:22NWNVLT4:6:${Math.floor(Math.random() * 10000)}:${Math.floor(Math.random() * 50000)}:${Math.floor(Math.random() * 20000)}`,
                    refName: 'NC_000913.3',
                    start: start,
                    end: start + Math.floor(Math.random() * 100) + 50,
                    mq: Math.floor(Math.random() * 61), // 0-60 mapping quality
                    mapq: Math.floor(Math.random() * 61),
                    flags: Math.random() > 0.1 ? 0 : (Math.random() > 0.5 ? 4 : 256), // Mostly normal, some unmapped/secondary
                    strand: Math.random() > 0.5 ? '+' : '-',
                    cigar: '100M',
                    seq: 'ATCGATCGATCG'.repeat(8),
                    qual: '!!!!!!!!!!!!'.repeat(8)
                });
            }
            return records;
        }

        // Test 1: Memory-efficient statistics calculation
        async function testStatisticsCalculation() {
            const container = document.getElementById('stats-results');
            container.innerHTML = '';
            
            try {
                addResult('stats-results', 'üß™ Testing memory-efficient statistics calculation...', 'info');
                
                // Test with different dataset sizes
                const testSizes = [50000, 150000, 300000];
                
                for (const size of testSizes) {
                    addResult('stats-results', `üìä Testing with ${size.toLocaleString()} records...`, 'info');
                    
                    const records = generateMockBamRecords(size);
                    const startTime = performance.now();
                    
                    // Simulate the new memory-efficient statistics calculation
                    let minMQ = Infinity;
                    let maxMQ = -Infinity;
                    let totalMQ = 0;
                    let unmappedCount = 0;
                    let secondaryCount = 0;
                    let supplementaryCount = 0;
                    
                    const STATS_CHUNK_SIZE = 10000;
                    for (let i = 0; i < records.length; i += STATS_CHUNK_SIZE) {
                        const chunk = records.slice(i, i + STATS_CHUNK_SIZE);
                        
                        for (const record of chunk) {
                            const mq = record.mq || record.mapq || 0;
                            minMQ = Math.min(minMQ, mq);
                            maxMQ = Math.max(maxMQ, mq);
                            totalMQ += mq;
                            
                            if ((record.flags & 4) !== 0) unmappedCount++;
                            if ((record.flags & 256) !== 0) secondaryCount++;
                            if ((record.flags & 2048) !== 0) supplementaryCount++;
                        }
                        
                        // Small delay to prevent blocking
                        if (i % 50000 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                    
                    const endTime = performance.now();
                    const avgMQ = totalMQ / records.length;
                    
                    addResult('stats-results', `‚úÖ ${size.toLocaleString()} records processed in ${(endTime - startTime).toFixed(1)}ms`, 'success');
                    addResult('stats-results', `   MQ stats: min=${minMQ}, max=${maxMQ}, avg=${avgMQ.toFixed(1)}`, 'info');
                    addResult('stats-results', `   Flags: unmapped=${unmappedCount}, secondary=${secondaryCount}`, 'info');
                }
                
                addResult('stats-results', 'üéâ All statistics calculation tests passed!', 'success');
                
            } catch (error) {
                addResult('stats-results', `‚ùå ERROR: ${error.message}`, 'error');
                addResult('stats-results', `Stack trace: ${error.stack}`, 'error');
            }
        }

        // Test 2: Early sampling mechanism
        async function testEarlySampling() {
            const container = document.getElementById('sampling-results');
            container.innerHTML = '';
            
            try {
                addResult('sampling-results', 'üß™ Testing early sampling mechanism...', 'info');
                
                // Test with dataset that should trigger early sampling
                const originalSize = 250000; // > 200k threshold
                const records = generateMockBamRecords(originalSize);
                
                addResult('sampling-results', `üìä Generated ${originalSize.toLocaleString()} records (above 200k threshold)`, 'info');
                
                const EXTREME_DATASET_THRESHOLD = 200000;
                const EARLY_SAMPLE_SIZE = 100000;
                
                let sampledRecords = [...records];
                
                if (sampledRecords.length > EXTREME_DATASET_THRESHOLD) {
                    addResult('sampling-results', `‚ö†Ô∏è Applying early sampling: ${sampledRecords.length} ‚Üí ${EARLY_SAMPLE_SIZE}`, 'warning');
                    
                    const startTime = performance.now();
                    
                    // Apply Fisher-Yates shuffle to first EARLY_SAMPLE_SIZE elements
                    for (let i = 0; i < EARLY_SAMPLE_SIZE; i++) {
                        const j = i + Math.floor(Math.random() * (sampledRecords.length - i));
                        [sampledRecords[i], sampledRecords[j]] = [sampledRecords[j], sampledRecords[i]];
                    }
                    
                    sampledRecords = sampledRecords.slice(0, EARLY_SAMPLE_SIZE);
                    
                    const endTime = performance.now();
                    
                    addResult('sampling-results', `‚úÖ Early sampling complete in ${(endTime - startTime).toFixed(1)}ms`, 'success');
                    addResult('sampling-results', `   Final size: ${sampledRecords.length.toLocaleString()} records`, 'info');
                }
                
                addResult('sampling-results', 'üéâ Early sampling test passed!', 'success');
                
            } catch (error) {
                addResult('sampling-results', `‚ùå ERROR: ${error.message}`, 'error');
            }
        }

        // Test 3: Memory-efficient chunked processing
        async function testChunkedProcessing() {
            const container = document.getElementById('chunked-results');
            container.innerHTML = '';
            
            try {
                addResult('chunked-results', 'üß™ Testing memory-efficient chunked processing...', 'info');
                
                const records = generateMockBamRecords(75000);
                const CHUNK_SIZE = 5000;
                
                addResult('chunked-results', `üìä Processing ${records.length.toLocaleString()} records in chunks of ${CHUNK_SIZE}`, 'info');
                
                const startTime = performance.now();
                let processedReads = [];
                
                for (let i = 0; i < records.length; i += CHUNK_SIZE) {
                    const chunkEnd = Math.min(i + CHUNK_SIZE, records.length);
                    const chunk = records.slice(i, chunkEnd);
                    
                    // Simulate record conversion
                    const chunkReads = chunk.map((record, idx) => ({
                        id: record.name,
                        chromosome: record.refName,
                        start: record.start + 1,
                        end: record.end + 1,
                        strand: record.strand,
                        mappingQuality: record.mq
                    }));
                    
                    // Use push.apply for better performance
                    processedReads.push(...chunkReads);
                    
                    // Log progress
                    if ((i / CHUNK_SIZE) % 5 === 0) {
                        const progress = ((chunkEnd / records.length) * 100).toFixed(1);
                        addResult('chunked-results', `   Progress: ${chunkEnd}/${records.length} (${progress}%)`, 'info');
                    }
                    
                    // Small delay for very large datasets
                    if (i % 20000 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                const endTime = performance.now();
                
                addResult('chunked-results', `‚úÖ Chunked processing complete in ${(endTime - startTime).toFixed(1)}ms`, 'success');
                addResult('chunked-results', `   Processed: ${processedReads.length.toLocaleString()} reads`, 'info');
                addResult('chunked-results', `   Memory efficient: No stack overflow!`, 'success');
                
            } catch (error) {
                addResult('chunked-results', `‚ùå ERROR: ${error.message}`, 'error');
            }
        }

        // Test 4: Extreme dataset simulation (316k records)
        async function testExtremeDataset() {
            const container = document.getElementById('extreme-results');
            const progressContainer = document.getElementById('extreme-progress');
            const progressBar = document.getElementById('extreme-progress-bar');
            
            container.innerHTML = '';
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            
            try {
                addResult('extreme-results', 'üö® Testing extreme dataset (316,372 records)...', 'warning');
                addResult('extreme-results', '‚ö†Ô∏è This simulates the exact scenario that caused stack overflow', 'warning');
                
                const extremeSize = 316372;
                
                // Generate records in chunks to avoid memory issues during generation
                addResult('extreme-results', 'üìä Generating extreme dataset...', 'info');
                updateProgress('extreme-progress-bar', 10);
                
                const records = generateMockBamRecords(extremeSize, 2791421, 2801422);
                updateProgress('extreme-progress-bar', 30);
                
                addResult('extreme-results', `‚úÖ Generated ${records.length.toLocaleString()} records`, 'success');
                
                // Test early sampling
                const EXTREME_DATASET_THRESHOLD = 200000;
                const EARLY_SAMPLE_SIZE = 100000;
                
                let processedRecords = [...records];
                
                if (processedRecords.length > EXTREME_DATASET_THRESHOLD) {
                    addResult('extreme-results', `üéØ Applying early sampling (${processedRecords.length} > ${EXTREME_DATASET_THRESHOLD})`, 'info');
                    updateProgress('extreme-progress-bar', 50);
                    
                    // Early sampling
                    for (let i = 0; i < EARLY_SAMPLE_SIZE; i++) {
                        const j = i + Math.floor(Math.random() * (processedRecords.length - i));
                        [processedRecords[i], processedRecords[j]] = [processedRecords[j], processedRecords[i]];
                    }
                    processedRecords = processedRecords.slice(0, EARLY_SAMPLE_SIZE);
                    
                    addResult('extreme-results', `‚úÖ Early sampling: ${records.length} ‚Üí ${processedRecords.length}`, 'success');
                    updateProgress('extreme-progress-bar', 70);
                }
                
                // Test memory-efficient statistics
                addResult('extreme-results', 'üìä Calculating statistics (memory-efficient)...', 'info');
                
                let minMQ = Infinity, maxMQ = -Infinity, totalMQ = 0;
                let unmappedCount = 0, secondaryCount = 0, supplementaryCount = 0;
                
                const STATS_CHUNK_SIZE = 10000;
                for (let i = 0; i < processedRecords.length; i += STATS_CHUNK_SIZE) {
                    const chunk = processedRecords.slice(i, i + STATS_CHUNK_SIZE);
                    
                    for (const record of chunk) {
                        const mq = record.mq || record.mapq || 0;
                        minMQ = Math.min(minMQ, mq);
                        maxMQ = Math.max(maxMQ, mq);
                        totalMQ += mq;
                        
                        if ((record.flags & 4) !== 0) unmappedCount++;
                        if ((record.flags & 256) !== 0) secondaryCount++;
                        if ((record.flags & 2048) !== 0) supplementaryCount++;
                    }
                    
                    if (i % 20000 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                updateProgress('extreme-progress-bar', 90);
                
                const avgMQ = totalMQ / processedRecords.length;
                
                addResult('extreme-results', `‚úÖ Statistics calculated successfully!`, 'success');
                addResult('extreme-results', `   MQ: min=${minMQ}, max=${maxMQ}, avg=${avgMQ.toFixed(1)}`, 'info');
                addResult('extreme-results', `   Flags: unmapped=${unmappedCount}, secondary=${secondaryCount}`, 'info');
                
                updateProgress('extreme-progress-bar', 100);
                
                addResult('extreme-results', 'üéâ EXTREME DATASET TEST PASSED!', 'success');
                addResult('extreme-results', '‚úÖ No stack overflow occurred!', 'success');
                addResult('extreme-results', '‚úÖ Memory usage remained stable!', 'success');
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                addResult('extreme-results', `‚ùå EXTREME DATASET TEST FAILED: ${error.message}`, 'error');
                addResult('extreme-results', `Stack trace: ${error.stack}`, 'error');
                progressContainer.style.display = 'none';
            }
        }

        // Initialize
        console.log('üöÄ BAM Stack Overflow Fix Test Suite initialized');
        addResult('stats-results', 'üöÄ Test suite ready. Click buttons to run tests.', 'info');
    </script>
</body>
</html> 