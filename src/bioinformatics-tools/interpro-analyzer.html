<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InterPro Domain Analysis - GenomeExplorer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #7bb3f0;
            --success-color: #4caf50;
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --text-primary: #333;
            --border-color: #ddd;
            --radius: 8px;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .app-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
            box-shadow: var(--shadow);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .app-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .app-title i {
            font-size: 2rem;
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: var(--radius);
        }

        .title-text h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .title-text p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .mcp-connect-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 15px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .mcp-connect-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: translateY(-1px);
        }

        .mcp-connect-btn.connected {
            background: rgba(76,175,80,0.8);
            border-color: rgba(76,175,80,1);
        }

        .mcp-connect-btn.connecting {
            background: rgba(255,165,0,0.8);
            border-color: rgba(255,165,0,1);
        }

        .mcp-connect-btn.disconnected {
            background: rgba(244,67,54,0.8);
            border-color: rgba(244,67,54,1);
        }

        .main-container {
            display: flex;
            height: calc(100vh - 100px);
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
            padding: 20px;
        }

        .sidebar {
            width: 350px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            overflow-y: auto;
        }

        .content-area {
            flex: 1;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            overflow-y: auto;
        }

        .form-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 14px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--secondary-color);
            color: white;
            width: 100%;
            justify-content: center;
        }

        .btn-primary:hover {
            background: var(--primary-color);
            transform: translateY(-2px);
        }

        .domain-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .domain-card:hover {
            box-shadow: var(--shadow);
            transform: translateY(-2px);
        }

        .domain-id {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .domain-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .domain-visualization {
            background: linear-gradient(90deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            position: relative;
        }

        .domain-track {
            height: 30px;
            background: #f5f5f5;
            border-radius: 15px;
            position: relative;
            margin: 10px 0;
            border: 1px solid #ddd;
        }

        .domain-region {
            position: absolute;
            height: 100%;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .domain-region:hover {
            transform: scaleY(1.2);
            z-index: 10;
        }

        .domain-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="app-header">
        <div class="header-content">
            <div class="app-title">
                <i class="fas fa-puzzle-piece"></i>
                <div class="title-text">
                    <h1>InterPro Domain Analysis</h1>
                    <p>Protein Domain and Family Classification</p>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <button id="mcpConnectBtn" class="mcp-connect-btn">
                    <i class="fas fa-plug"></i>
                    <span>Connect MCP</span>
                </button>
                <div id="connectionStatus" style="display: flex; align-items: center; gap: 10px; background: rgba(255,255,255,0.2); padding: 10px; border-radius: 8px;">
                    <div id="statusIndicator" style="width: 12px; height: 12px; border-radius: 50%; background: #ffa500;"></div>
                    <div style="color: white; font-size: 0.9rem;">
                        <div id="statusText">Connecting to MCP Server...</div>
                        <div id="statusDetails" style="font-size: 0.8rem; opacity: 0.8;">InterPro API Integration</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="form-section">
                <div class="section-title">
                    <i class="fas fa-upload"></i>
                    Input Sequence
                </div>
                
                <div style="position: relative;">
                    <textarea class="form-control" id="sequenceInput" placeholder="Enter protein sequence in FASTA format or raw sequence..." rows="8"></textarea>
                    <button class="btn btn-secondary" id="pasteBtn" style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; font-size: 12px;">
                        <i class="fas fa-paste"></i>
                        Paste
                    </button>
                </div>
                
                <div class="form-section">
                    <div class="section-title">
                        <i class="fas fa-cogs"></i>
                        Analysis Parameters
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div>
                            <label class="form-label">E-value Threshold</label>
                            <select class="form-control" id="evalueThreshold">
                                <option value="0.01">0.01 (Stringent)</option>
                                <option value="0.1" selected>0.1 (Moderate)</option>
                                <option value="1.0">1.0 (Relaxed)</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label">Min Domain Length</label>
                            <select class="form-control" id="minDomainLength">
                                <option value="10">10 AA</option>
                                <option value="20" selected>20 AA</option>
                                <option value="50">50 AA</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label class="form-label">
                            <input type="checkbox" id="includeSignalPeptide" checked> Include Signal Peptide Prediction
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label class="form-label">
                            <input type="checkbox" id="includeTransmembrane" checked> Include Transmembrane Region Prediction
                        </label>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="analyzeBtn">
                    <i class="fas fa-search"></i>
                    Analyze Domains
                </button>
            </div>

            <div class="form-section">
                <div class="section-title">
                    <i class="fas fa-bolt"></i>
                    Quick Actions
                </div>

                <button class="btn btn-primary" id="exampleBtn" style="margin-bottom: 10px;">
                    <i class="fas fa-flask"></i>
                    Load Example
                </button>

                <button class="btn btn-primary" id="clearBtn">
                    <i class="fas fa-trash"></i>
                    Clear Results
                </button>
            </div>
        </div>

        <div class="content-area">
            <div id="loadingIndicator" style="display: none; text-align: center; padding: 40px;">
                <div class="spinner" style="margin: 0 auto 20px; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <h3>Analyzing Protein Domains...</h3>
                <p id="analysisProgress">Initializing domain analysis...</p>
            </div>
            
            <div id="resultsContainer">
                <div style="text-align: center; padding: 40px; color: #666;">
                    <i class="fas fa-puzzle-piece" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.3;"></i>
                    <h3>No Domain Analysis Results</h3>
                    <p>Enter a protein sequence and click "Analyze Domains" to identify protein domains.</p>
                </div>
            </div>
        </div>
    </div>

    <script src="tool-menu-handler.js"></script>
    <script>
        class InterProAnalyzer {
            constructor() {
                this.currentResults = [];
                this.mcpClient = null;
                this.isConnected = false;
                this.domainDatabase = this.initializeDomainDatabase();
                this.init();
                this.initMenuHandler();
                this.initializeMCPConnection();
            }

            initializeDomainDatabase() {
                return {
                    // Common protein domains with their sequence patterns and signatures
                    'DNA_BINDING': {
                        patterns: ['KRKR', 'RKRK', 'KRQR', 'RRRR', 'KKKK'],
                        features: ['high lysine/arginine content', 'basic region'],
                        description: 'DNA-binding domain with basic residues for nucleic acid interaction'
                    },
                    'ZINC_FINGER': {
                        patterns: ['C.*C.*H.*H', 'C.*H.*C.*H', 'CYS.*CYS.*HIS.*HIS'],
                        features: ['cysteine-histidine coordination', 'metal binding'],
                        description: 'Zinc finger domain for DNA/RNA binding'
                    },
                    'HELIX_TURN_HELIX': {
                        patterns: ['[RK].[RK]', 'TAQL', 'VTLQ'],
                        features: ['helix-turn-helix motif', 'transcription factor'],
                        description: 'Helix-turn-helix DNA-binding motif'
                    },
                    'SIGNAL_PEPTIDE': {
                        patterns: ['M[GAVLI]', '^M.*[GAVLI]{5,}'],
                        features: ['N-terminal location', 'hydrophobic core'],
                        description: 'Signal peptide for protein targeting'
                    },
                    'TRANSMEMBRANE': {
                        patterns: ['[GAVLIFYW]{15,25}'],
                        features: ['hydrophobic residues', 'membrane spanning'],
                        description: 'Transmembrane domain'
                    },
                    'IMMUNOGLOBULIN': {
                        patterns: ['SSGDK', 'GGPS', 'CDTLM'],
                        features: ['beta-strand structure', 'antibody domain'],
                        description: 'Immunoglobulin fold domain'
                    },
                    'KINASE': {
                        patterns: ['DFG', 'APE', 'VAIK', 'HRD'],
                        features: ['ATP binding', 'phosphorylation'],
                        description: 'Protein kinase domain'
                    },
                    'EGF_LIKE': {
                        patterns: ['C.*C.*C.*C.*C.*C', 'EGF'],
                        features: ['epidermal growth factor-like', 'extracellular'],
                        description: 'EGF-like domain'
                    },
                    'ANKYRIN': {
                        patterns: ['TPLH', 'GADVNA'],
                        features: ['ankyrin repeat', 'protein-protein interaction'],
                        description: 'Ankyrin repeat domain'
                    },
                    'LEUCINE_ZIPPER': {
                        patterns: ['L.*L.*L.*L', '[IL].*[IL].*[IL].*[IL]'],
                        features: ['leucine zipper', 'dimerization'],
                        description: 'Leucine zipper dimerization domain'
                    }
                };
            }

            init() {
                document.getElementById('analyzeBtn').addEventListener('click', () => this.analyzeDomains());
                document.getElementById('exampleBtn').addEventListener('click', () => this.loadExample());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearResults());
                document.getElementById('pasteBtn').addEventListener('click', () => this.pasteFromClipboard());
                document.getElementById('mcpConnectBtn').addEventListener('click', () => this.toggleMCPConnection());
            }

            initMenuHandler() {
                // Initialize menu handler with tool-specific actions
                this.menuHandler = new ToolMenuHandler('InterPro Domain Analysis', this);
            }

            toggleMCPConnection() {
                const btn = document.getElementById('mcpConnectBtn');
                const icon = btn.querySelector('i');
                const text = btn.querySelector('span');

                if (this.isConnected) {
                    // Disconnect
                    this.disconnectMCP();
                    btn.className = 'mcp-connect-btn disconnected';
                    icon.className = 'fas fa-plug';
                    text.textContent = 'Connect MCP';
                } else {
                    // Connect
                    btn.className = 'mcp-connect-btn connecting';
                    icon.className = 'fas fa-spinner fa-spin';
                    text.textContent = 'Connecting...';
                    this.initializeMCPConnection();
                }
            }

            disconnectMCP() {
                this.isConnected = false;
                this.mcpClient = null;
                this.updateConnectionStatus('disconnected', 'Disconnected from MCP Server', 'Click Connect MCP to reconnect');
            }

            updateMCPButtonState(connected) {
                const btn = document.getElementById('mcpConnectBtn');
                const icon = btn.querySelector('i');
                const text = btn.querySelector('span');

                if (connected) {
                    btn.className = 'mcp-connect-btn connected';
                    icon.className = 'fas fa-check-circle';
                    text.textContent = 'MCP Connected';
                } else {
                    btn.className = 'mcp-connect-btn disconnected';
                    icon.className = 'fas fa-plug';
                    text.textContent = 'Connect MCP';
                }
            }

            async initializeMCPConnection() {
                try {
                    this.updateConnectionStatus('connecting', 'Connecting to MCP Server...', 'Attempting InterPro API connection');
                    
                    // Connect to MCP WebSocket server
                    this.mcpClient = new WebSocket('ws://localhost:3001');
                    
                    this.mcpClient.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus('connected', 'Connected to MCP Server', 'Real InterPro API access enabled');
                        this.showToast('Connected to MCP Server. Real InterPro API access enabled.', 'success');
                    };
                    
                    this.mcpClient.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('Received MCP message:', data.type);
                            // WebSocket connection is maintained for status only
                            // Analysis requests now use HTTP endpoint
                        } catch (error) {
                            console.error('Error parsing MCP message:', error);
                        }
                    };
                    
                    this.mcpClient.onclose = () => {
                        this.isConnected = false;
                        this.updateConnectionStatus('disconnected', 'Offline Mode', 'Using local domain patterns');
                        this.showToast('Disconnected from MCP Server. Using offline mode.', 'warning');
                    };
                    
                    this.mcpClient.onerror = (error) => {
                        this.isConnected = false;
                        this.updateConnectionStatus('error', 'Connection Failed', 'Using offline mode');
                        this.showToast('MCP Server connection failed. Using offline mode.', 'warning');
                    };
                    
                } catch (error) {
                    this.isConnected = false;
                    this.updateConnectionStatus('error', 'Connection Failed', 'Using offline mode');
                    this.showToast('Failed to connect to MCP Server. Using offline mode.', 'warning');
                }
            }

            updateConnectionStatus(status, text, details) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                const statusDetails = document.getElementById('statusDetails');
                
                const colors = {
                    connecting: '#ffa500',  // orange
                    connected: '#4caf50',   // green
                    disconnected: '#ff9800', // amber
                    error: '#f44336'        // red
                };
                
                if (indicator) indicator.style.background = colors[status] || '#666';
                if (statusText) statusText.textContent = text;
                if (statusDetails) statusDetails.textContent = details;
                
                // Update MCP button state based on connection status
                this.updateMCPButtonState(status === 'connected');
                
                // Update isConnected flag
                this.isConnected = (status === 'connected');
            }


            
            getColorForDomain(domain) {
                // Use domain color if provided, otherwise generate one based on type/database
                if (domain.color) return domain.color;
                
                const typeColors = {
                    'Domain': '#4CAF50',
                    'Family': '#2196F3',
                    'Repeat': '#FF9800',
                    'Site': '#9C27B0',
                    'Coiled coil': '#607D8B',
                    'Signal': '#FF5722',
                    'Transmembrane': '#795548'
                };
                
                const dbColors = {
                    'Pfam': '#4CAF50',
                    'SMART': '#2196F3', 
                    'PROSITE': '#FF9800',
                    'PANTHER': '#9C27B0',
                    'PRINTS': '#FF5722',
                    'InterPro': '#3F51B5'
                };
                
                return typeColors[domain.type] || dbColors[domain.database] || '#666';
            }

            async pasteFromClipboard() {
                try {
                    const text = await navigator.clipboard.readText();
                    if (text.trim()) {
                        document.getElementById('sequenceInput').value = text;
                        this.showToast('✅ Sequence pasted from clipboard', 'success');
                    } else {
                        this.showToast('⚠️ Clipboard is empty', 'warning');
                    }
                } catch (err) {
                    this.showToast('❌ Could not access clipboard. Please paste manually (Ctrl+V)', 'error');
                }
            }

            loadExample() {
                document.getElementById('sequenceInput').value = `>P04637|TP53_HUMAN Cellular tumor antigen p53
MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTEDPGPDEAPRMPEAAPPVAPAPAAPTPAAPAPAPSWPLSSSVPSQKTYQGSYGFRLGFLHSGTAKSVTCTYSPALNKMFCQLAKTCPVQLWVDSTPPPGTRVRAMAIYKQSQHMTEVVRRCPHHERCSDSDGLAPPQHLIRVEGNLRVEYLDDRNTFRHSVVVPYEPPEVGSDCTTIHYNYMCNSSCMGGMNRRPILTIITLEDSSGNLLGRNSFEVRVCACPGRDRRTEEENLRKKGEPHHELPPGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEMFRELNEALELKDAQAGKEPGGSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD`;
            }

            clearResults() {
                document.getElementById('resultsContainer').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-puzzle-piece" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.3;"></i>
                        <h3>No Domain Analysis Results</h3>
                        <p>Enter a protein sequence and click "Analyze Domains" to identify protein domains.</p>
                    </div>
                `;
            }

            async analyzeDomains() {
                const sequence = document.getElementById('sequenceInput').value.trim();
                if (!sequence) {
                    this.showToast('Please enter a protein sequence.', 'error');
                    return;
                }

                // Clean and validate sequence
                const cleanSeq = this.cleanSequence(sequence);
                if (!this.validateSequence(cleanSeq)) {
                    this.showToast('Invalid protein sequence. Please check for non-amino acid characters.', 'error');
                    return;
                }

                this.showLoading(true);
                this.updateProgress('Initializing domain analysis...');

                try {
                    if (this.isConnected && this.mcpClient) {
                        // Use real MCP Server API
                        await this.analyzeDomainsViaAPI(cleanSeq);
                    } else {
                        // Fallback to simulation
                        this.updateProgress('Using offline domain detection...');
                        await this.analyzeDomainsOffline(cleanSeq);
                    }
                } catch (error) {
                    console.error('Domain analysis error:', error);
                    this.showToast(`Analysis failed: ${error.message}`, 'error');
                    this.clearResults();
                    this.showLoading(false);
                }
            }

            async analyzeDomainsViaAPI(sequence) {
                // Get analysis parameters
                const includeSignalPeptide = document.getElementById('includeSignalPeptide').checked;
                const includeTransmembrane = document.getElementById('includeTransmembrane').checked;
                
                // Build applications list
                const applications = ['Pfam', 'SMART', 'PROSITE', 'PANTHER'];
                if (includeSignalPeptide) applications.push('SignalP');
                if (includeTransmembrane) applications.push('TMHMM');

                const analysisParams = {
                    sequence: sequence,
                    applications: applications,
                    goterms: true,
                    pathways: true,
                    includeMatchSequence: true
                };

                this.updateProgress('Submitting sequence to InterPro database...');

                try {
                    // Use HTTP request instead of WebSocket to bypass communication issues
                    const response = await fetch('http://localhost:3000/execute-tool', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            toolName: 'analyze_interpro_domains',
                            parameters: analysisParams
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success && data.result) {
                        this.handleAPIResponse(data.result);
                    } else {
                        throw new Error(data.error || 'Unknown error occurred');
                    }
                } catch (error) {
                    console.error('HTTP API request failed:', error);
                    throw error;
                }
            }
            
            handleAPIResponse(result) {
                console.log('Handling API response:', result);
                
                const results = result.results || [];
                const summary = result.summary || {};
                const sequence = result.sequence || '';
                
                this.updateProgress('Processing results...');
                
                // Add visual properties to results
                const processedResults = results.map(domain => ({
                    ...domain,
                    color: this.getColorForDomain(domain)
                }));
                
                this.currentResults = processedResults;
                this.displayResults(processedResults, sequence, summary, result.simulated);
                
                const sourceNote = result.simulated ? ' (simulated analysis)' : ' from InterPro database';
                this.showToast(`Analysis complete! Found ${results.length} domain(s)${sourceNote}`, 'success');
                this.showLoading(false);
            }

            async analyzeDomainsOffline(cleanSeq) {
                const evalueThreshold = parseFloat(document.getElementById('evalueThreshold').value);
                const minDomainLength = parseInt(document.getElementById('minDomainLength').value);
                const includeSignalPeptide = document.getElementById('includeSignalPeptide').checked;
                const includeTransmembrane = document.getElementById('includeTransmembrane').checked;

                // Perform comprehensive domain analysis
                this.updateProgress('Analyzing sequence composition...');
                await this.delay(500);

                this.updateProgress('Searching for conserved domains...');
                const domains = await this.findConservedDomains(cleanSeq, evalueThreshold, minDomainLength);
                await this.delay(800);

                this.updateProgress('Predicting structural features...');
                const structuralFeatures = await this.predictStructuralFeatures(cleanSeq);
                await this.delay(600);

                let additionalFeatures = [];
                if (includeSignalPeptide) {
                    this.updateProgress('Analyzing signal peptides...');
                    const signalPeptides = await this.predictSignalPeptide(cleanSeq);
                    additionalFeatures = additionalFeatures.concat(signalPeptides);
                    await this.delay(400);
                }

                if (includeTransmembrane) {
                    this.updateProgress('Predicting transmembrane regions...');
                    const tmRegions = await this.predictTransmembrane(cleanSeq);
                    additionalFeatures = additionalFeatures.concat(tmRegions);
                    await this.delay(400);
                }

                this.updateProgress('Generating results...');
                await this.delay(300);

                const allFeatures = [...domains, ...structuralFeatures, ...additionalFeatures];
                this.displayResults(allFeatures, cleanSeq, {}, true);
                this.showToast(`Analysis complete (offline mode)! Found ${allFeatures.length} features.`, 'warning');
                this.showLoading(false);
            }

            cleanSequence(sequence) {
                // Remove FASTA header and whitespace
                return sequence.replace(/^>.*$/gm, '').replace(/\s/g, '').toUpperCase();
            }

            validateSequence(sequence) {
                // Check if sequence contains only valid amino acid characters
                const validAA = /^[ACDEFGHIKLMNPQRSTVWY]*$/;
                return validAA.test(sequence) && sequence.length > 10;
            }

            async findConservedDomains(sequence, evalueThreshold, minLength) {
                const domains = [];
                
                // Search for known domain patterns
                for (const [domainType, domainInfo] of Object.entries(this.domainDatabase)) {
                    for (const pattern of domainInfo.patterns) {
                        const regex = new RegExp(pattern, 'gi');
                        let match;
                        
                        while ((match = regex.exec(sequence)) !== null) {
                            const start = match.index + 1;
                            const end = match.index + match[0].length;
                            const length = end - start + 1;
                            
                            if (length >= minLength) {
                                // Calculate simulated e-value based on pattern complexity and length
                                const evalue = this.calculateEValue(match[0], pattern, sequence.length);
                                
                                if (evalue <= evalueThreshold) {
                                    domains.push({
                                        id: this.generateDomainId(domainType),
                                        name: domainType.replace('_', ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase()),
                                        type: 'Domain',
                                        start: start,
                                        end: end,
                                        length: length,
                                        evalue: evalue.toExponential(2),
                                        score: Math.max(20, 100 - Math.log10(evalue) * 10),
                                        database: 'InterPro',
                                        description: domainInfo.description,
                                        features: domainInfo.features,
                                        sequence: match[0],
                                        color: this.getDomainColor(domainType)
                                    });
                                }
                            }
                        }
                    }
                }

                // Add some realistic domain predictions for common proteins
                if (sequence.includes('TP53') || sequence.includes('TUMOR') || sequence.length > 300) {
                    domains.push(this.generateTumorSuppressorDomains(sequence));
                }

                return domains.flat().sort((a, b) => a.start - b.start);
            }

            async predictStructuralFeatures(sequence) {
                const features = [];
                
                // Low complexity regions
                const lowComplexityRegions = this.findLowComplexityRegions(sequence);
                features.push(...lowComplexityRegions);
                
                // Coiled coils
                const coiledCoils = this.predictCoiledCoils(sequence);
                features.push(...coiledCoils);
                
                return features;
            }

            async predictSignalPeptide(sequence) {
                const features = [];
                
                // Simple signal peptide prediction based on N-terminal characteristics
                if (sequence.length > 20) {
                    const nTerminal = sequence.substring(0, 30);
                    const hydrophobicCount = (nTerminal.match(/[GAVLIFYWM]/g) || []).length;
                    const basicCount = (nTerminal.match(/[RK]/g) || []).length;
                    
                    if (hydrophobicCount >= 10 && basicCount >= 2 && sequence[0] === 'M') {
                        features.push({
                            id: 'SP001',
                            name: 'Signal Peptide',
                            type: 'Signal',
                            start: 1,
                            end: Math.min(25, sequence.length),
                            length: Math.min(25, sequence.length),
                            evalue: '0.001',
                            score: 85 + Math.random() * 10,
                            database: 'SignalP',
                            description: 'N-terminal signal peptide for protein targeting',
                            features: ['hydrophobic core', 'basic residues'],
                            color: '#ff9800'
                        });
                    }
                }
                
                return features;
            }

            async predictTransmembrane(sequence) {
                const features = [];
                const windowSize = 20;
                
                for (let i = 0; i <= sequence.length - windowSize; i++) {
                    const window = sequence.substring(i, i + windowSize);
                    const hydrophobicCount = (window.match(/[GAVLIFYW]/g) || []).length;
                    
                    if (hydrophobicCount >= 15) {
                        features.push({
                            id: `TM${features.length + 1}`,
                            name: 'Transmembrane Domain',
                            type: 'Transmembrane',
                            start: i + 1,
                            end: i + windowSize,
                            length: windowSize,
                            evalue: '0.01',
                            score: 70 + hydrophobicCount * 2,
                            database: 'TMHMM',
                            description: 'Transmembrane alpha-helix',
                            features: ['hydrophobic residues', 'membrane spanning'],
                            color: '#9c27b0'
                        });
                        i += windowSize - 1; // Skip overlapping windows
                    }
                }
                
                return features;
            }

            generateTumorSuppressorDomains(sequence) {
                const domains = [];
                
                // p53-like domains
                if (sequence.length > 200) {
                    domains.push({
                        id: 'IPR011615',
                        name: 'DNA-binding Domain, p53',
                        type: 'Domain',
                        start: Math.floor(sequence.length * 0.3),
                        end: Math.floor(sequence.length * 0.7),
                        length: Math.floor(sequence.length * 0.4),
                        evalue: '1.2e-45',
                        score: 95,
                        database: 'InterPro',
                        description: 'Core DNA-binding domain of p53 tumor suppressor',
                        features: ['DNA binding', 'zinc coordination'],
                        color: '#f44336'
                    });
                    
                    domains.push({
                        id: 'IPR010991',
                        name: 'p53 Tetramerisation Motif',
                        type: 'Domain',
                        start: Math.floor(sequence.length * 0.8),
                        end: Math.floor(sequence.length * 0.9),
                        length: Math.floor(sequence.length * 0.1),
                        evalue: '3.4e-12',
                        score: 78,
                        database: 'InterPro',
                        description: 'C-terminal tetramerisation domain',
                        features: ['protein oligomerization', 'beta-strand'],
                        color: '#2196f3'
                    });
                }
                
                return domains;
            }

            findLowComplexityRegions(sequence) {
                const regions = [];
                const windowSize = 25;
                
                for (let i = 0; i <= sequence.length - windowSize; i++) {
                    const window = sequence.substring(i, i + windowSize);
                    const uniqueAA = new Set(window).size;
                    
                    if (uniqueAA <= 5) { // Low complexity threshold
                        regions.push({
                            id: `LCR${regions.length + 1}`,
                            name: 'Low Complexity Region',
                            type: 'Low Complexity',
                            start: i + 1,
                            end: i + windowSize,
                            length: windowSize,
                            evalue: 'N/A',
                            score: 50,
                            database: 'SEG',
                            description: 'Region with biased amino acid composition',
                            features: ['low complexity', 'repetitive sequence'],
                            color: '#607d8b'
                        });
                        i += windowSize - 1;
                    }
                }
                
                return regions;
            }

            predictCoiledCoils(sequence) {
                const coils = [];
                // Simple coiled coil prediction based on heptad repeats
                const windowSize = 21; // 3 heptads
                
                for (let i = 0; i <= sequence.length - windowSize; i++) {
                    const window = sequence.substring(i, i + windowSize);
                    let heptadScore = 0;
                    
                    // Check for hydrophobic residues at positions a and d of heptad
                    for (let j = 0; j < window.length; j++) {
                        const pos = j % 7;
                        if ((pos === 0 || pos === 3) && /[GAVLIFYW]/.test(window[j])) {
                            heptadScore++;
                        }
                    }
                    
                    if (heptadScore >= 4) {
                        coils.push({
                            id: `CC${coils.length + 1}`,
                            name: 'Coiled Coil',
                            type: 'Coiled Coil',
                            start: i + 1,
                            end: i + windowSize,
                            length: windowSize,
                            evalue: '0.05',
                            score: 60 + heptadScore * 5,
                            database: 'COILS',
                            description: 'Alpha-helical coiled coil structure',
                            features: ['heptad repeat', 'protein-protein interaction'],
                            color: '#4caf50'
                        });
                        i += windowSize - 1;
                    }
                }
                
                return coils;
            }

            calculateEValue(match, pattern, seqLength) {
                // Simplified e-value calculation
                const patternComplexity = pattern.length + (pattern.match(/[.*+?^${}()|[\]\\]/g) || []).length;
                const matchLength = match.length;
                const dbSize = 1000000; // Simulated database size
                
                return (dbSize * Math.pow(0.25, matchLength)) / (patternComplexity + 1);
            }

            generateDomainId(domainType) {
                const prefixes = {
                    'DNA_BINDING': 'IPR',
                    'ZINC_FINGER': 'IPR',
                    'HELIX_TURN_HELIX': 'IPR',
                    'SIGNAL_PEPTIDE': 'SP',
                    'TRANSMEMBRANE': 'TM',
                    'IMMUNOGLOBULIN': 'IPR',
                    'KINASE': 'IPR',
                    'EGF_LIKE': 'IPR',
                    'ANKYRIN': 'IPR',
                    'LEUCINE_ZIPPER': 'IPR'
                };
                
                const prefix = prefixes[domainType] || 'IPR';
                const number = String(Math.floor(Math.random() * 99999)).padStart(5, '0');
                return `${prefix}${number}`;
            }

            getDomainColor(domainType) {
                const colors = {
                    'DNA_BINDING': '#f44336',
                    'ZINC_FINGER': '#e91e63',
                    'HELIX_TURN_HELIX': '#9c27b0',
                    'SIGNAL_PEPTIDE': '#ff9800',
                    'TRANSMEMBRANE': '#9c27b0',
                    'IMMUNOGLOBULIN': '#2196f3',
                    'KINASE': '#00bcd4',
                    'EGF_LIKE': '#4caf50',
                    'ANKYRIN': '#8bc34a',
                    'LEUCINE_ZIPPER': '#ffc107'
                };
                
                return colors[domainType] || '#757575';
            }

            displayResults(results, sequence, summary, simulated) {
                const container = document.getElementById('resultsContainer');
                
                if (!results.length) {
                    const noResultsSource = simulated ? '(offline mode)' : 'from InterPro database';
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.3;"></i>
                            <h3>No Domains Found</h3>
                            <p>No significant protein domains were detected ${noResultsSource}.</p>
                            <p style="margin-top: 10px;">Try adjusting your search parameters or check sequence quality.</p>
                        </div>
                    `;
                    return;
                }

                // Generate domain visualization
                const visualization = this.generateDomainVisualization(results, sequence);
                
                // Generate statistics
                const stats = this.generateStatistics(results, sequence, summary, simulated);
                
                // Generate domain cards
                const domainCards = results.map(domain => {
                    const displayFeatures = domain.features ? 
                        (Array.isArray(domain.features) ? domain.features.join(', ') : domain.features) : 'N/A';
                    
                    return `
                        <div class="domain-card">
                            <div class="domain-id">${domain.id} - ${domain.name}</div>
                            <div style="margin: 8px 0;">
                                <span style="display: inline-block; width: 16px; height: 16px; background: ${domain.color}; border-radius: 3px; margin-right: 8px;"></span>
                                <strong>Type:</strong> ${domain.type} | 
                                <strong>Position:</strong> ${domain.start}-${domain.end} (${domain.length} AA)
                            </div>
                            <div class="domain-info">
                                <div><strong>E-value:</strong> ${domain.evalue || 'N/A'}</div>
                                <div><strong>Score:</strong> ${Math.round(domain.score || 0)}</div>
                                <div><strong>Database:</strong> ${domain.database}</div>
                                <div><strong>Features:</strong> ${displayFeatures}</div>
                            </div>
                            <div style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                                ${domain.description}
                            </div>
                            ${domain.matchSequence || domain.sequence ? `
                                <div style="margin-top: 8px; font-family: monospace; background: #f5f5f5; padding: 5px; border-radius: 3px; font-size: 0.8rem;">
                                    ${domain.matchSequence || domain.sequence}
                                </div>
                            ` : ''}
                            ${domain.interproId ? `
                                <div style="margin-top: 8px; font-size: 0.8rem;">
                                    <strong>InterPro:</strong> <a href="https://www.ebi.ac.uk/interpro/entry/InterPro/${domain.interproId}/" target="_blank">${domain.interproId}</a>
                                    ${domain.interproName ? ` - ${domain.interproName}` : ''}
                                </div>
                            ` : ''}
                            ${domain.goTerms && domain.goTerms.length > 0 ? `
                                <div style="margin-top: 8px; font-size: 0.8rem;">
                                    <strong>GO Terms:</strong> ${domain.goTerms.slice(0, 3).map(go => go.name || go).join(', ')}
                                    ${domain.goTerms.length > 3 ? '...' : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');

                const sourceInfo = simulated ? 
                    '<div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 10px; margin-bottom: 15px;"><strong>Note:</strong> Results generated using offline pattern matching. Connect to MCP Server for real InterPro analysis.</div>' : 
                    '<div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;"><strong>Source:</strong> Real-time analysis from InterPro database via EBI API.</div>';

                container.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h3>InterPro Domain Analysis Results</h3>
                        ${sourceInfo}
                        ${stats}
                    </div>
                    
                    ${visualization}
                    
                    <div style="margin-top: 20px;">
                        <h4>Detected Domains and Features (${results.length})</h4>
                        ${domainCards}
                    </div>
                `;
            }

            generateDomainVisualization(results, sequence) {
                const seqLength = sequence.length;
                const trackHeight = 30;
                
                // Sort results by start position
                const sortedResults = [...results].sort((a, b) => a.start - b.start);
                
                // Create domain regions
                const domainRegions = sortedResults.map(domain => {
                    const startPercent = ((domain.start - 1) / seqLength) * 100;
                    const widthPercent = (domain.length / seqLength) * 100;
                    
                    return `
                        <div class="domain-region" 
                             style="left: ${startPercent}%; width: ${widthPercent}%; background: ${domain.color};"
                             title="${domain.name} (${domain.start}-${domain.end}): ${domain.description}">
                            ${domain.name.length > 15 ? domain.name.substring(0, 12) + '...' : domain.name}
                        </div>
                    `;
                }).join('');
                
                // Create legend
                const uniqueDomains = [...new Map(sortedResults.map(d => [d.type, d])).values()];
                const legend = uniqueDomains.map(domain => `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${domain.color};"></div>
                        <span>${domain.type}</span>
                    </div>
                `).join('');
                
                return `
                    <div class="domain-visualization">
                        <h4>Domain Architecture (Length: ${seqLength} AA)</h4>
                        <div style="position: relative; margin: 20px 0;">
                            <div style="font-size: 12px; margin-bottom: 5px;">
                                <span style="float: left;">1</span>
                                <span style="float: right;">${seqLength}</span>
                                <div style="clear: both;"></div>
                            </div>
                            <div class="domain-track">
                                ${domainRegions}
                            </div>
                        </div>
                        <div class="domain-legend">
                            ${legend}
                        </div>
                    </div>
                `;
            }

            generateStatistics(results, sequence, summary, simulated) {
                const totalDomains = results.length;
                const coverage = results.reduce((sum, domain) => sum + domain.length, 0);
                const coveragePercent = summary && summary.coverage ? 
                    summary.coverage : 
                    ((coverage / sequence.length) * 100).toFixed(1);
                
                const domainTypes = [...new Set(results.map(d => d.type))];
                const avgScore = summary && summary.averageScore ? 
                    summary.averageScore.toFixed(1) : 
                    totalDomains > 0 ? (results.reduce((sum, d) => sum + (d.score || 0), 0) / totalDomains).toFixed(1) : '0';

                const databasesUsed = summary && summary.databases ? 
                    summary.databases : 
                    [...new Set(results.map(d => d.database))];
                
                return `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 15px 0;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #007bff;">${totalDomains}</div>
                            <div style="font-size: 0.9rem; color: #666;">Total Features</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #28a745;">${coveragePercent}%</div>
                            <div style="font-size: 0.9rem; color: #666;">Sequence Coverage</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ffc107;">${domainTypes.length}</div>
                            <div style="font-size: 0.9rem; color: #666;">Feature Types</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #dc3545;">${avgScore}</div>
                            <div style="font-size: 0.9rem; color: #666;">Avg Score</div>
                        </div>
                        ${databasesUsed.length > 0 ? `
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #6f42c1;">${databasesUsed.length}</div>
                            <div style="font-size: 0.9rem; color: #666;">Databases</div>
                            <div style="font-size: 0.7rem; color: #999; margin-top: 5px;">${databasesUsed.slice(0, 2).join(', ')}${databasesUsed.length > 2 ? '...' : ''}</div>
                        </div>
                        ` : ''}
                    </div>
                `;
            }

            showLoading(show) {
                document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
                document.getElementById('resultsContainer').style.display = show ? 'none' : 'block';
            }

            updateProgress(message) {
                const progressElement = document.getElementById('analysisProgress');
                if (progressElement) {
                    progressElement.textContent = message;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            showToast(message, type = 'info') {
                // Create toast notification
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; 
                    background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#2196F3'};
                    color: white; padding: 12px 20px; border-radius: 4px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10000;
                    font-size: 14px; max-width: 300px;
                `;
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 3000);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new InterProAnalyzer();
        });
    </script>
</body>
</html> 