<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gene Annotation Refine - Genome AI Studio</title>
    <link rel="stylesheet" href="../renderer/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --text-color: #2c3e50;
            --border-color: #dee2e6;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            box-sizing: border-box;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
            width: 100%;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 0.25rem;
        }

        .header-actions {
            position: absolute;
            top: 1rem;
            right: 2rem;
        }

        .header-actions .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
        }

        .header-actions .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .main-container {
            width: 100%;
            margin: 0;
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            box-sizing: border-box;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 0.75rem;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
                gap: 0.75rem;
            }
        }

        /* Additional responsive styles */
        @media (max-width: 480px) {
            .main-container {
                padding: 0.25rem;
                gap: 0.5rem;
            }
            
            .card {
                padding: 0.75rem;
            }
            
            .header h1 {
                font-size: 1.4rem;
            }
            
            .header .subtitle {
                font-size: 0.8rem;
            }
        }

        /* Ensure full width for all elements */
        .file-upload-area,
        .form-group,
        .btn,
        input,
        textarea,
        select {
            width: 100%;
            box-sizing: border-box;
        }

        /* Responsive text areas */
        textarea {
            min-height: 120px;
            resize: vertical;
        }

        @media (max-width: 768px) {
            textarea {
                min-height: 100px;
            }
        }

        .card {
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            width: 100%;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .card {
                padding: 1rem;
            }
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
        }

        .card-header h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        .btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-warning {
            background: var(--warning-color);
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: var(--accent-color);
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .btn-lg {
            padding: 1rem 2rem;
            font-size: 1.1rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary-color), var(--success-color));
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: 500;
        }

        .status-info {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid var(--secondary-color);
        }

        .status-success {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 4px solid var(--success-color);
        }

        .status-warning {
            background: #fff3e0;
            color: #ef6c00;
            border-left: 4px solid var(--warning-color);
        }

        .status-error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid var(--accent-color);
        }

        .annotation-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .annotation-section {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
        }

        .annotation-section.original {
            border-color: var(--warning-color);
        }

        .annotation-section.refined {
            border-color: var(--success-color);
        }

        .annotation-section h4 {
            margin-bottom: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
        }

        .annotation-field {
            margin-bottom: 0.75rem;
        }

        .annotation-field label {
            font-weight: 500;
            color: var(--text-color);
            font-size: 0.9rem;
        }

        .annotation-field .value {
            background: #f8f9fa;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            margin-top: 0.25rem;
            word-break: break-word;
        }

        .diff-highlight {
            background: #fff3cd;
            padding: 0.1rem 0.2rem;
            border-radius: 3px;
        }

        .diff-added {
            background: #d4edda;
            color: #155724;
        }

        .diff-removed {
            background: #f8d7da;
            color: #721c24;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .file-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-upload-area:hover {
            border-color: var(--secondary-color);
            background: #f8f9fa;
        }

        .file-upload-area.dragover {
            border-color: var(--secondary-color);
            background: #e3f2fd;
        }

        .file-upload-area i {
            font-size: 2rem;
            color: var(--secondary-color);
            margin-bottom: 1rem;
        }

        .extracted-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .extracted-info h5 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .extracted-info .info-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: white;
            border-radius: 4px;
            border-left: 3px solid var(--secondary-color);
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .gene-info-display {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .gene-info-display h4 {
            color: var(--primary-color);
            margin-bottom: 0.75rem;
        }

        .gene-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .gene-info-item {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            border-left: 3px solid var(--secondary-color);
        }

        .gene-info-item label {
            font-weight: 500;
            color: var(--text-color);
            font-size: 0.85rem;
        }

        .gene-info-item .value {
            color: var(--primary-color);
            font-weight: 600;
            margin-top: 0.25rem;
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                padding: 1rem;
            }
            
            .annotation-comparison {
                grid-template-columns: 1fr;
            }
        }

        /* Research Method Selection Styles */
        .research-method-selection {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.3s ease;
            background: white;
            flex: 1;
            min-width: 150px;
        }

        .radio-option:hover {
            border-color: var(--secondary-color);
            background: #f8f9fa;
        }

        .radio-option input[type="radio"] {
            margin-right: 0.5rem;
            margin: 0;
        }

        .radio-option input[type="radio"]:checked + .radio-label {
            color: var(--secondary-color);
            font-weight: 600;
        }

        .radio-option:has(input[type="radio"]:checked) {
            border-color: var(--secondary-color);
            background: #e3f2fd;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            color: var(--text-color);
        }

        .radio-label i {
            font-size: 1.1rem;
        }

        .research-section {
            margin-top: 1rem;
        }

        .checkbox-option {
            display: flex;
            align-items: center;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
        }

        .checkbox-option input[type="checkbox"] {
            margin-right: 0.5rem;
            margin: 0;
        }

        .checkbox-option span {
            font-weight: 500;
            color: var(--text-color);
        }

        .checkbox-option:hover span {
            color: var(--secondary-color);
        }

        @media (max-width: 768px) {
            .research-method-selection {
                flex-direction: column;
            }
            
            .radio-option {
                min-width: auto;
            }
        }
        /* Deep Research Progress Styles */
        .deep-research-progress {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #007bff;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .progress-header h4 {
            margin: 0;
            color: #007bff;
            font-size: 16px;
        }
        
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .progress-bar {
            flex: 1;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .progress-text {
            font-weight: 500;
            color: #495057;
            min-width: 200px;
        }
        
        .progress-details {
            border-top: 1px solid #dee2e6;
            padding-top: 15px;
        }
        
        .progress-log {
            max-height: 300px;
            overflow-y: auto;
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
        }
        
        .log-entry {
            display: flex;
            gap: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #f1f3f4;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-time {
            font-family: monospace;
            font-size: 12px;
            color: #6c757d;
            min-width: 80px;
        }
        
        .log-message {
            flex: 1;
            font-size: 13px;
        }
        
        .log-entry.info .log-message {
            color: #495057;
        }
        
        .log-entry.success .log-message {
            color: #28a745;
            font-weight: 500;
        }
        
        .log-entry.error .log-message {
            color: #dc3545;
            font-weight: 500;
        }
        
        .log-entry.warning .log-message {
            color: #ffc107;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <i class="fas fa-dna"></i>
            Gene Annotation Refine
        </h1>
        <div class="subtitle">Enhance gene annotations using Deep Research Reports and AI-powered analysis</div>
        <div class="header-actions">
            <button class="btn btn-sm" onclick="showHelp()" title="Show keyboard shortcuts (F1)">
                <i class="fas fa-keyboard"></i> Shortcuts
            </button>
        </div>
    </div>

    <div class="main-container">
        <!-- Gene Selection Panel -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-search"></i>
                <h3>Gene Selection</h3>
            </div>
            
            <div class="form-group">
                <label for="geneInput">Gene Name or Locus Tag</label>
                <input type="text" id="geneInput" placeholder="e.g., lysC, b4024, or search for genes...">
                <button class="btn btn-sm" onclick="searchGene()" style="margin-top: 0.5rem;">
                    <i class="fas fa-search"></i> Search Gene
                </button>
            </div>

            <div id="geneInfoDisplay" class="gene-info-display hidden">
                <h4>Selected Gene Information</h4>
                <div id="geneInfoContent" class="gene-info-grid"></div>
            </div>

            <div class="form-group">
                <label for="currentAnnotation">Current Annotation</label>
                <textarea id="currentAnnotation" placeholder="Current gene annotation will appear here..." readonly></textarea>
            </div>
        </div>

        <!-- Research Report Upload Panel -->
        <div class="card">
            <div class="card-header">
                <i class="fas fa-file-upload"></i>
                <h3>Deep Research Report</h3>
            </div>
            
            <!-- Research Method Selection -->
            <div class="form-group">
                <label>Research Method</label>
                <div class="research-method-selection">
                    <label class="radio-option">
                        <input type="radio" name="researchMethod" value="upload" checked>
                        <span class="radio-label">
                            <i class="fas fa-file-upload"></i>
                            Upload Report
                        </span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="researchMethod" value="deep-research">
                        <span class="radio-label">
                            <i class="fas fa-search-plus"></i>
                            Deep Research Agent
                        </span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="researchMethod" value="paste">
                        <span class="radio-label">
                            <i class="fas fa-paste"></i>
                            Paste Text
                        </span>
                    </label>
                </div>
            </div>

            <!-- Upload Section -->
            <div id="uploadSection" class="research-section">
                <div class="file-upload-area" id="fileUploadArea" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-cloud-upload-alt"></i>
                    <h4>Upload Research Report</h4>
                    <p>Click to select or drag and drop your Deep Research Report</p>
                    <p class="text-muted">Supported formats: PDF, TXT, DOC, DOCX</p>
                    <input type="file" id="fileInput" accept=".pdf,.txt,.doc,.docx" style="display: none;">
                </div>

                <div id="fileInfo" class="hidden">
                    <div class="status-message status-info">
                        <i class="fas fa-file"></i>
                        <span id="fileName"></span> - <span id="fileSize"></span>
                    </div>
                </div>
            </div>

            <!-- Deep Research Section -->
            <div id="deepResearchSection" class="research-section hidden">
                <div class="form-group">
                    <label for="deepResearchQuery">Research Query</label>
                    <textarea id="deepResearchQuery" placeholder="Enter your research query for the selected gene..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="researchLanguage">Language</label>
                    <select id="researchLanguage">
                        <option value="English">English</option>
                        <option value="Chinese">Chinese</option>
                        <option value="Spanish">Spanish</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="maxResults">Max Results</label>
                    <input type="number" id="maxResults" value="5" min="1" max="20">
                </div>
                
                <div class="form-group">
                    <label class="checkbox-option">
                        <input type="checkbox" id="enableCitations" checked>
                        <span>Include Citations</span>
                    </label>
                    <label class="checkbox-option">
                        <input type="checkbox" id="enableReferences" checked>
                        <span>Include References</span>
                    </label>
                    <label class="checkbox-option">
                        <input type="checkbox" id="enableImages">
                        <span>Include Images</span>
                    </label>
                </div>
                
                <button class="btn btn-lg" onclick="performDeepResearch()" id="deepResearchBtn">
                    <i class="fas fa-search-plus"></i> Perform Deep Research
                </button>
            </div>

            <!-- Paste Text Section -->
            <div id="pasteSection" class="research-section hidden">
                <div class="form-group">
                    <label for="reportText">Paste Report Text</label>
                    <textarea id="reportText" placeholder="Paste your Deep Research Report text here..."></textarea>
                    <button class="btn btn-sm" onclick="loadSampleReport()" style="margin-top: 0.5rem;">
                        <i class="fas fa-flask"></i> Load Sample Report
                    </button>
                </div>
            </div>

            <button class="btn btn-lg" onclick="processReport()" id="processBtn">
                <i class="fas fa-cogs"></i> Process Report
            </button>
            <button class="btn btn-sm" onclick="testButtonClick()" style="margin-left: 10px;">
                <i class="fas fa-bug"></i> Test Button
            </button>
        </div>

        <!-- Processing Status -->
        <div id="processingStatus" class="card hidden">
            <div class="card-header">
                <i class="fas fa-cog fa-spin"></i>
                <h3>Processing Report</h3>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div id="statusMessage" class="status-message status-info">
                <i class="fas fa-info-circle"></i>
                <span id="statusText">Initializing...</span>
            </div>
        </div>

        <!-- Extracted Information -->
        <div id="extractedInfo" class="card hidden">
            <div class="card-header">
                <i class="fas fa-microscope"></i>
                <h3>Extracted Information</h3>
            </div>
            
            <div id="extractedContent" class="extracted-info">
                <!-- Extracted information will be displayed here -->
            </div>
        </div>

        <!-- Annotation Comparison -->
        <div id="annotationComparison" class="card hidden">
            <div class="card-header">
                <i class="fas fa-balance-scale"></i>
                <h3>Annotation Comparison</h3>
            </div>
            
            <div class="annotation-comparison">
                <div class="annotation-section original">
                    <h4><i class="fas fa-file-alt"></i> Original Annotation</h4>
                    <div id="originalAnnotation"></div>
                </div>
                
                <div class="annotation-section refined">
                    <h4><i class="fas fa-magic"></i> Refined Annotation</h4>
                    <div id="refinedAnnotation"></div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-success" onclick="acceptRefinedAnnotation()">
                    <i class="fas fa-check"></i> Accept Refined Annotation
                </button>
                <button class="btn btn-warning" onclick="editRefinedAnnotation()">
                    <i class="fas fa-edit"></i> Edit Refined Annotation
                </button>
                <button class="btn" onclick="rejectRefinedAnnotation()">
                    <i class="fas fa-times"></i> Reject Changes
                </button>
            </div>
        </div>

        <!-- Edit Annotation Modal -->
        <div id="editModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Edit Refined Annotation</h3>
                    <button class="close-btn" onclick="closeEditModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="editProduct">Product/Function</label>
                        <textarea id="editProduct" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="editNote">Note</label>
                        <textarea id="editNote" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="editEC">EC Number</label>
                        <input type="text" id="editEC">
                    </div>
                    <div class="form-group">
                        <label for="editGO">GO Terms</label>
                        <input type="text" id="editGO">
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-success" onclick="saveEditedAnnotation()">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                    <button class="btn" onclick="closeEditModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script src="./langextract-integration.js"></script>
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script>
        // Global variables
        let selectedGene = null;
        let currentAnnotations = null;
        let extractedInfo = null;
        let refinedAnnotation = null;
        let langExtractIntegration = null;
        let deepResearchAgent = null;
        let multiAgentSystem = null;

        // Initialize the tool
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeTool();
            setupEventListeners();
        });

        async function initializeTool() {
            console.log('Gene Annotation Refine tool initialized');
            
            // Initialize LangExtract integration
            langExtractIntegration = new LangExtractIntegration();
            await langExtractIntegration.initialize();
            
            // Initialize Deep Research Agent integration
            await initializeDeepResearchIntegration();
            
            // Check if we have a gene passed from the main window
            const urlParams = new URLSearchParams(window.location.search);
            const geneName = urlParams.get('gene');
            if (geneName) {
                document.getElementById('geneInput').value = geneName;
                searchGene();
            }
        }

        function setupEventListeners() {
            // File upload handling
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('fileUploadArea');

            fileInput.addEventListener('change', handleFileSelect);
            
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            // Enter key for gene search
            document.getElementById('geneInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchGene();
                }
            });

            // Research method selection
            const researchMethodRadios = document.querySelectorAll('input[name="researchMethod"]');
            researchMethodRadios.forEach(radio => {
                radio.addEventListener('change', handleResearchMethodChange);
            });

            // Add click event listener to Process Report button
            const processBtn = document.getElementById('processBtn');
            if (processBtn) {
                processBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Process Report button clicked');
                    processReport();
                });
            } else {
                console.error('Process Report button not found');
            }

            // Global keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
        }

        function handleKeyboardShortcuts(e) {
            // Check if user is typing in an input field or textarea
            const activeElement = document.activeElement;
            const isInputField = activeElement && (
                activeElement.tagName === 'INPUT' || 
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true'
            );

            // Global shortcuts (work everywhere)
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'c':
                        // Copy functionality - allow in input fields for normal copy behavior
                        if (!isInputField) {
                            e.preventDefault();
                            handleCopy();
                        }
                        // In input fields, let the browser handle normal copy
                        break;
                    case 'v':
                        // Paste functionality - allow in input fields for normal paste behavior
                        if (!isInputField) {
                            e.preventDefault();
                            handlePaste();
                        }
                        // In input fields, let the browser handle normal paste
                        break;
                    case 'a':
                        // Select all functionality - allow in input fields for normal select all
                        if (!isInputField) {
                            e.preventDefault();
                            handleSelectAll();
                        }
                        // In input fields, let the browser handle normal select all
                        break;
                    case 's':
                        // Save functionality - always prevent default to avoid page save
                        e.preventDefault();
                        handleSave();
                        break;
                    case 'f':
                        // Find/Search functionality
                        e.preventDefault();
                        handleFind();
                        break;
                    case 'n':
                        // New/Reset functionality
                        e.preventDefault();
                        handleNew();
                        break;
                    case 'z':
                        // Undo functionality - only prevent if not in input field
                        if (!isInputField) {
                            e.preventDefault();
                            handleUndo();
                        }
                        break;
                    case 'y':
                        // Redo functionality - only prevent if not in input field
                        if (!isInputField) {
                            e.preventDefault();
                            handleRedo();
                        }
                        break;
                }
            }

            // Function key shortcuts
            switch (e.key) {
                case 'F1':
                    e.preventDefault();
                    showHelp();
                    break;
                case 'F5':
                    e.preventDefault();
                    refreshTool();
                    break;
                case 'Escape':
                    e.preventDefault();
                    handleEscape();
                    break;
            }

            // Additional text editing shortcuts
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'x':
                        // Cut functionality - only prevent if not in input field
                        if (!isInputField) {
                            e.preventDefault();
                            handleCut();
                        }
                        break;
                    case 'd':
                        // Duplicate line functionality
                        if (isInputField) {
                            e.preventDefault();
                            handleDuplicateLine();
                        }
                        break;
                    case 'l':
                        // Select line functionality
                        if (isInputField) {
                            e.preventDefault();
                            handleSelectLine();
                        }
                        break;
                }
            }
        }

        function handleCopy() {
            try {
                // Get the current text selection or focused element content
                const activeElement = document.activeElement;
                let textToCopy = '';
                let copySource = '';

                // Check for text selection first
                if (window.getSelection && window.getSelection().toString().trim()) {
                    textToCopy = window.getSelection().toString();
                    copySource = 'selected text';
                } else if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    // If focused on input/textarea, copy its content
                    if (activeElement.value && activeElement.value.trim()) {
                        textToCopy = activeElement.value;
                        copySource = activeElement.id || 'focused field';
                    } else {
                        showStatus('No content to copy in focused field', 'warning');
                        return;
                    }
                } else {
                    // Find the most relevant content to copy
                    const contentSources = [
                        { element: document.getElementById('reportText'), name: 'report text' },
                        { element: document.getElementById('currentAnnotation'), name: 'current annotation' },
                        { element: document.getElementById('deepResearchQuery'), name: 'research query' },
                        { element: document.getElementById('extractedContent'), name: 'extracted information' }
                    ];
                    
                    // Find the first visible and non-empty content
                    for (const source of contentSources) {
                        if (source.element && !source.element.classList.contains('hidden') && 
                            source.element.offsetParent !== null) {
                            
                            if (source.element.tagName === 'TEXTAREA' || source.element.tagName === 'INPUT') {
                                if (source.element.value && source.element.value.trim()) {
                                    textToCopy = source.element.value;
                                    copySource = source.name;
                                    break;
                                }
                            } else {
                                // For div elements, get text content
                                const textContent = source.element.textContent || source.element.innerText;
                                if (textContent && textContent.trim()) {
                                    textToCopy = textContent.trim();
                                    copySource = source.name;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!textToCopy) {
                        showStatus('No content available to copy', 'warning');
                        return;
                    }
                }

                // Use the Clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        showStatus(`Content copied to clipboard (${copySource})`, 'success');
                    }).catch(err => {
                        console.error('Failed to copy: ', err);
                        fallbackCopyTextToClipboard(textToCopy, copySource);
                    });
                } else {
                    // Fallback for older browsers
                    fallbackCopyTextToClipboard(textToCopy, copySource);
                }
            } catch (error) {
                console.error('Copy failed:', error);
                showStatus('Copy failed: ' + error.message, 'error');
            }
        }

        function handlePaste() {
            try {
                // Check if we're in a text input context
                const activeElement = document.activeElement;
                const isTextInput = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
                
                // Use the Clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.readText().then(text => {
                        if (!text || !text.trim()) {
                            showStatus('No content in clipboard to paste', 'warning');
                            return;
                        }
                        
                        if (isTextInput) {
                            // Paste into the currently focused input/textarea
                            const start = activeElement.selectionStart || 0;
                            const end = activeElement.selectionEnd || 0;
                            const currentValue = activeElement.value || '';
                            
                            // Insert text at cursor position
                            const newValue = currentValue.substring(0, start) + text + currentValue.substring(end);
                            activeElement.value = newValue;
                            
                            // Set cursor position after pasted text
                            const newCursorPos = start + text.length;
                            activeElement.setSelectionRange(newCursorPos, newCursorPos);
                            
                            showStatus(`Content pasted into ${activeElement.id || 'focused field'}`, 'success');
                        } else {
                            // Find the most appropriate text area to paste into
                            const targetAreas = [
                                document.getElementById('reportText'),
                                document.getElementById('deepResearchQuery'),
                                document.getElementById('currentAnnotation')
                            ];
                            
                            // Find the first visible text area
                            let targetArea = null;
                            for (const area of targetAreas) {
                                if (area && !area.classList.contains('hidden') && area.offsetParent !== null) {
                                    targetArea = area;
                                    break;
                                }
                            }
                            
                            if (targetArea) {
                                targetArea.value = text;
                                targetArea.focus();
                                targetArea.select();
                                showStatus(`Content pasted into ${targetArea.id}`, 'success');
                            } else {
                                showStatus('No suitable text area found for pasting', 'warning');
                            }
                        }
                    }).catch(err => {
                        console.error('Failed to paste: ', err);
                        if (err.name === 'NotAllowedError') {
                            showStatus('Paste permission denied. Please use Ctrl+V in a text field.', 'warning');
                        } else {
                            showStatus('Paste failed: ' + err.message, 'error');
                        }
                    });
                } else {
                    // Fallback for older browsers or non-secure contexts
                    if (isTextInput) {
                        showStatus('Please use Ctrl+V to paste in the focused field', 'info');
                    } else {
                        showStatus('Please focus on a text area and use Ctrl+V to paste', 'info');
                    }
                }
            } catch (error) {
                console.error('Paste failed:', error);
                showStatus('Paste failed: ' + error.message, 'error');
            }
        }

        function handleSelectAll() {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                // Select all text in the currently focused input/textarea
                activeElement.select();
                showStatus('Text selected in focused field', 'info');
            } else {
                // Find the most relevant text area to select
                const textAreas = [
                    document.getElementById('reportText'),
                    document.getElementById('currentAnnotation'),
                    document.getElementById('deepResearchQuery')
                ];
                
                // Find the first visible and non-empty text area
                for (const textArea of textAreas) {
                    if (textArea && !textArea.classList.contains('hidden') && textArea.offsetParent !== null && textArea.value.trim()) {
                        textArea.focus();
                        textArea.select();
                        showStatus('Text selected in ' + textArea.id, 'info');
                        return;
                    }
                }
                
                // If no text areas have content, select the report text area anyway
                const reportTextArea = document.getElementById('reportText');
                if (reportTextArea) {
                    reportTextArea.focus();
                    reportTextArea.select();
                    showStatus('Text area focused for selection', 'info');
                }
            }
        }

        function handleSave() {
            // Save current refined annotation if available
            if (refinedAnnotation) {
                saveRefinedAnnotation(refinedAnnotation);
            } else {
                showStatus('No refined annotation to save', 'warning');
            }
        }

        function handleFind() {
            // Focus on gene search input
            const geneInput = document.getElementById('geneInput');
            if (geneInput) {
                geneInput.focus();
                geneInput.select();
            }
        }

        function handleNew() {
            // Reset the tool
            resetTool();
        }

        function handleUndo() {
            // For now, just show a message since we don't have undo history
            showStatus('Undo functionality not yet implemented', 'info');
        }

        function handleRedo() {
            // For now, just show a message since we don't have redo history
            showStatus('Redo functionality not yet implemented', 'info');
        }

        function handleCut() {
            // First copy the content, then clear it
            handleCopy();
            
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                // Clear the focused element
                activeElement.value = '';
                showStatus('Content cut to clipboard', 'success');
            } else {
                // Find and clear the most relevant text area
                const textAreas = [
                    document.getElementById('reportText'),
                    document.getElementById('currentAnnotation'),
                    document.getElementById('deepResearchQuery')
                ];
                
                for (const textArea of textAreas) {
                    if (textArea && !textArea.classList.contains('hidden') && 
                        textArea.offsetParent !== null && textArea.value.trim()) {
                        textArea.value = '';
                        textArea.focus();
                        showStatus('Content cut to clipboard', 'success');
                        return;
                    }
                }
                
                showStatus('No content to cut', 'warning');
            }
        }

        function handleDuplicateLine() {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'TEXTAREA')) {
                const start = activeElement.selectionStart || 0;
                const end = activeElement.selectionEnd || 0;
                const value = activeElement.value;
                
                // Find the current line
                const beforeCursor = value.substring(0, start);
                const afterCursor = value.substring(end);
                const lines = beforeCursor.split('\n');
                const currentLine = lines[lines.length - 1];
                
                // Insert the current line below
                const newValue = beforeCursor + currentLine + afterCursor;
                activeElement.value = newValue;
                
                // Position cursor at the end of the duplicated line
                const newCursorPos = start + currentLine.length;
                activeElement.setSelectionRange(newCursorPos, newCursorPos);
                
                showStatus('Line duplicated', 'success');
            } else {
                showStatus('Duplicate line only works in text areas', 'warning');
            }
        }

        function handleSelectLine() {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'TEXTAREA')) {
                const start = activeElement.selectionStart || 0;
                const value = activeElement.value;
                
                // Find line boundaries
                const beforeCursor = value.substring(0, start);
                const afterCursor = value.substring(start);
                
                const lastNewlineBefore = beforeCursor.lastIndexOf('\n');
                const firstNewlineAfter = afterCursor.indexOf('\n');
                
                const lineStart = lastNewlineBefore + 1;
                const lineEnd = firstNewlineAfter === -1 ? value.length : start + firstNewlineAfter;
                
                // Select the entire line
                activeElement.setSelectionRange(lineStart, lineEnd);
                showStatus('Line selected', 'info');
            } else {
                showStatus('Select line only works in text areas', 'warning');
            }
        }

        function showHelp() {
            // Create a modal dialog for help
            const helpModal = document.createElement('div');
            helpModal.className = 'modal';
            helpModal.style.display = 'block';
            helpModal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h3><i class="fas fa-keyboard"></i> Keyboard Shortcuts</h3>
                        <button class="close-btn" onclick="closeHelpModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="shortcuts-section">
                            <h4><i class="fas fa-globe"></i> Global Shortcuts</h4>
                            <div class="shortcut-list">
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>C</kbd>
                                    <span>Copy content to clipboard</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>V</kbd>
                                    <span>Paste content from clipboard</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>A</kbd>
                                    <span>Select all text</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>S</kbd>
                                    <span>Save refined annotation</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>F</kbd>
                                    <span>Focus on gene search</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>N</kbd>
                                    <span>Reset tool</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="shortcuts-section">
                            <h4><i class="fas fa-key"></i> Function Keys</h4>
                            <div class="shortcut-list">
                                <div class="shortcut-item">
                                    <kbd>F1</kbd>
                                    <span>Show this help</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>F5</kbd>
                                    <span>Refresh tool</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Escape</kbd>
                                    <span>Close dialogs/cancel operations</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="shortcuts-section">
                            <h4><i class="fas fa-edit"></i> Text Area Shortcuts</h4>
                            <div class="shortcut-list">
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>A</kbd>
                                    <span>Select all text in focused field</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>C</kbd>
                                    <span>Copy selected text</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>V</kbd>
                                    <span>Paste text</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>X</kbd>
                                    <span>Cut selected text</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>Z</kbd>
                                    <span>Undo (if supported by browser)</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>Y</kbd>
                                    <span>Redo (if supported by browser)</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>D</kbd>
                                    <span>Duplicate current line</span>
                                </div>
                                <div class="shortcut-item">
                                    <kbd>Ctrl</kbd> + <kbd>L</kbd>
                                    <span>Select current line</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" onclick="closeHelpModal()">Close</button>
                    </div>
                </div>
            `;
            
            // Add styles for the help modal
            const style = document.createElement('style');
            style.textContent = `
                .shortcuts-section {
                    margin-bottom: 1.5rem;
                }
                
                .shortcuts-section h4 {
                    color: var(--primary-color);
                    margin-bottom: 0.75rem;
                    font-size: 1rem;
                }
                
                .shortcut-list {
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                }
                
                .shortcut-item {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 0.5rem;
                    background: #f8f9fa;
                    border-radius: 4px;
                }
                
                .shortcut-item kbd {
                    background: #e9ecef;
                    border: 1px solid #adb5bd;
                    border-radius: 3px;
                    box-shadow: 0 1px 0 rgba(0,0,0,0.2);
                    color: #495057;
                    display: inline-block;
                    font-size: 0.8rem;
                    font-weight: 700;
                    line-height: 1;
                    padding: 2px 4px;
                    white-space: nowrap;
                    min-width: 20px;
                    text-align: center;
                }
                
                .shortcut-item span {
                    color: var(--text-color);
                    font-size: 0.9rem;
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(helpModal);
            
            // Close on escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeHelpModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        function closeHelpModal() {
            const helpModal = document.querySelector('.modal');
            if (helpModal) {
                helpModal.remove();
            }
        }

        function refreshTool() {
            // Refresh the tool state
            showStatus('Tool refreshed', 'info');
            console.log('Tool refreshed');
        }

        function handleEscape() {
            // Close any open modals or dialogs
            const editModal = document.getElementById('editModal');
            if (editModal && !editModal.classList.contains('hidden')) {
                closeEditModal();
            }
        }

        function resetTool() {
            // Reset all form fields and state
            document.getElementById('geneInput').value = '';
            document.getElementById('reportText').value = '';
            document.getElementById('currentAnnotation').value = '';
            
            // Hide all result panels
            document.getElementById('geneInfoDisplay').classList.add('hidden');
            document.getElementById('extractedInfo').classList.add('hidden');
            document.getElementById('annotationComparison').classList.add('hidden');
            document.getElementById('processingStatus').classList.add('hidden');
            
            // Reset global variables
            selectedGene = null;
            currentAnnotations = null;
            extractedInfo = null;
            refinedAnnotation = null;
            
            showStatus('Tool reset successfully', 'success');
        }

        // Fallback copy function for older browsers
        function fallbackCopyTextToClipboard(text, copySource = 'content') {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showStatus(`Content copied to clipboard (${copySource})`, 'success');
                } else {
                    showStatus('Copy failed', 'error');
                }
            } catch (err) {
                console.error('Fallback copy failed: ', err);
                showStatus('Copy failed: ' + err.message, 'error');
            }
            
            document.body.removeChild(textArea);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                await handleFileSelect({ target: { files: files } });
            }
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                displayFileInfo(file);
                await readFileContent(file);
            }
        }

        function displayFileInfo(file) {
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            document.getElementById('fileInfo').classList.remove('hidden');
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function readFileContent(file) {
            // Check file type and extension
            const fileName = file.name.toLowerCase();
            const fileType = file.type;
            
            console.log('Processing file:', fileName, 'Type:', fileType);
            
            if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    document.getElementById('reportText').value = content;
                    showStatus('Text file loaded successfully', 'success');
                };
                
                reader.onerror = function() {
                    showStatus('Error reading text file', 'error');
                };
                
                reader.readAsText(file);
            } else if (fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
                      fileName.endsWith('.docx')) {
                // For Word documents (.docx)
                await handleWordDocument(file);
            } else if (fileType === 'application/msword' || fileName.endsWith('.doc')) {
                // For older Word documents (.doc)
                await handleWordDocument(file);
            } else if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                // For PDF files
                handlePDFDocument(file);
            } else {
                // Try to read as text for other file types
                console.log('Attempting to read file as text:', fileType, fileName);
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    document.getElementById('reportText').value = content;
                    showStatus('File loaded as text', 'success');
                };
                
                reader.onerror = function() {
                    showStatus('Error reading file as text', 'error');
                };
                
                reader.readAsText(file);
            }
        }

        async function handleWordDocument(file) {
            showStatus('Processing Word document...', 'info');
            
            try {
                // Check if mammoth.js is available
                if (typeof mammoth !== 'undefined') {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({arrayBuffer: arrayBuffer});
                    
                    if (result.text) {
                        document.getElementById('reportText').value = result.text;
                        showStatus('Word document processed successfully', 'success');
                    } else {
                        throw new Error('No text content found in Word document');
                    }
                } else {
                    // Fallback if mammoth.js is not available
                    showStatus('Word document detected. Please copy and paste the content from the document into the text area below.', 'warning');
                    
                    const instruction = `
Please copy the content from your Word document and paste it below:

1. Open the Word document
2. Select all text (Ctrl+A)
3. Copy the text (Ctrl+C)
4. Paste it in the text area below (Ctrl+V)

Alternatively, you can save the Word document as a .txt file and upload that instead.
                    `;
                    
                    document.getElementById('reportText').value = instruction;
                }
            } catch (error) {
                console.error('Error processing Word document:', error);
                showStatus('Error processing Word document: ' + error.message, 'error');
                
                // Fallback instruction
                const instruction = `
Error processing Word document. Please copy and paste the content manually:

1. Open the Word document
2. Select all text (Ctrl+A)
3. Copy the text (Ctrl+C)
4. Paste it in the text area below (Ctrl+V)

Alternatively, you can save the Word document as a .txt file and upload that instead.
                `;
                
                document.getElementById('reportText').value = instruction;
            }
        }

        function handlePDFDocument(file) {
            // For PDF files, we'll also provide instructions
            showStatus('PDF document detected. Please copy and paste the content from the PDF into the text area below.', 'warning');
            
            const instruction = `
Please copy the content from your PDF document and paste it below:

1. Open the PDF document
2. Select all text (Ctrl+A)
3. Copy the text (Ctrl+C)
4. Paste it in the text area below (Ctrl+V)

Alternatively, you can convert the PDF to a .txt file and upload that instead.
            `;
            
            document.getElementById('reportText').value = instruction;
        }

        async function searchGene() {
            const geneName = document.getElementById('geneInput').value.trim();
            if (!geneName) {
                showStatus('Please enter a gene name or locus tag', 'warning');
                return;
            }

            showStatus('Searching for gene...', 'info');
            
            try {
                // This would integrate with the main genome browser
                const geneInfo = await searchGeneInGenome(geneName);
                
                if (geneInfo) {
                    selectedGene = geneInfo;
                    displayGeneInfo(geneInfo);
                    loadCurrentAnnotation(geneInfo);
                    showStatus('Gene found successfully', 'success');
                } else {
                    showStatus('Gene not found in current genome', 'error');
                }
            } catch (error) {
                console.error('Error searching for gene:', error);
                showStatus('Error searching for gene: ' + error.message, 'error');
            }
        }

        async function searchGeneInGenome(geneName) {
            // This would integrate with the main window's genome browser
            // For now, we'll simulate the search
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Simulate gene search result
                    resolve({
                        name: geneName,
                        locusTag: geneName.startsWith('b') ? geneName : 'b4024',
                        chromosome: 'NC_000913.3',
                        start: 3423681,
                        end: 3424651,
                        strand: '+',
                        type: 'CDS',
                        product: 'Lysine-sensitive aspartokinase 3',
                        note: 'Catalyzes the phosphorylation of aspartate to form aspartyl phosphate',
                        ec: '2.7.2.4',
                        go: 'GO:0004072, GO:0005524, GO:0005737'
                    });
                }, 1000);
            });
        }

        function displayGeneInfo(geneInfo) {
            const container = document.getElementById('geneInfoContent');
            container.innerHTML = `
                <div class="gene-info-item">
                    <label>Gene Name</label>
                    <div class="value">${geneInfo.name}</div>
                </div>
                <div class="gene-info-item">
                    <label>Locus Tag</label>
                    <div class="value">${geneInfo.locusTag}</div>
                </div>
                <div class="gene-info-item">
                    <label>Position</label>
                    <div class="value">${geneInfo.start} - ${geneInfo.end}</div>
                </div>
                <div class="gene-info-item">
                    <label>Strand</label>
                    <div class="value">${geneInfo.strand}</div>
                </div>
                <div class="gene-info-item">
                    <label>Type</label>
                    <div class="value">${geneInfo.type}</div>
                </div>
                <div class="gene-info-item">
                    <label>Product</label>
                    <div class="value">${geneInfo.product}</div>
                </div>
            `;
            
            document.getElementById('geneInfoDisplay').classList.remove('hidden');
        }

        function loadCurrentAnnotation(geneInfo) {
            const annotation = `Product: ${geneInfo.product}
Note: ${geneInfo.note}
EC Number: ${geneInfo.ec || 'N/A'}
GO Terms: ${geneInfo.go || 'N/A'}`;
            
            document.getElementById('currentAnnotation').value = annotation;
            currentAnnotations = geneInfo;
            
            // Auto-generate Deep Research query if Deep Research method is selected
            const deepResearchRadio = document.querySelector('input[name="researchMethod"][value="deep-research"]');
            if (deepResearchRadio && deepResearchRadio.checked) {
                generateDeepResearchQuery();
            }
        }

        async function processReport() {
            console.log('processReport function called');
            
            const reportText = document.getElementById('reportText').value.trim();
            console.log('Report text length:', reportText.length);
            
            if (!reportText) {
                showStatus('Please upload a file or paste report text', 'warning');
                return;
            }

            if (!selectedGene) {
                showStatus('Please select a gene first', 'warning');
                return;
            }

            console.log('Starting report processing...');
            updateProgress(10, 'Parsing research report...');

            try {
                // Step 1: Parse the research report
                updateProgress(20, 'Extracting gene function information...');
                console.log('Calling extractGeneFunctionInfo...');
                extractedInfo = await extractGeneFunctionInfo(reportText, selectedGene);
                console.log('Extracted info:', extractedInfo);
                
                updateProgress(50, 'Integrating with existing annotation...');
                // Step 2: Integrate with existing annotation using LLM
                console.log('Calling integrateAnnotations...');
                refinedAnnotation = await integrateAnnotations(currentAnnotations, extractedInfo);
                console.log('Refined annotation:', refinedAnnotation);
                
                updateProgress(80, 'Preparing comparison...');
                // Step 3: Display comparison
                displayExtractedInfo(extractedInfo);
                displayAnnotationComparison(currentAnnotations, refinedAnnotation);
                
                updateProgress(100, 'Processing complete!');
                showStatus('Report processed successfully', 'success');
                
            } catch (error) {
                console.error('Error processing report:', error);
                showStatus('Error processing report: ' + error.message, 'error');
            } finally {
                showProcessingStatus(false);
            }
        }

        async function extractGeneFunctionInfo(reportText, geneInfo) {
            try {
                if (!langExtractIntegration) {
                    throw new Error('LangExtract integration not initialized');
                }

                // Use LangExtract integration to extract gene function information
                const extractedInfo = await langExtractIntegration.extractGeneSpecificInfo(reportText, geneInfo.name);
                
                // Validate the extracted information
                const validation = langExtractIntegration.validateExtractedInfo(extractedInfo);
                
                if (!validation.isValid) {
                    console.warn('Validation warnings:', validation.warnings);
                }

                return extractedInfo;

            } catch (error) {
                console.error('Error extracting gene function info:', error);
                
                // Fallback to simulated data if extraction fails
                return {
                    function: 'Catalyzes the phosphorylation of aspartate to form aspartyl phosphate, the first step in the biosynthesis of lysine, methionine, and threonine',
                    pathway: 'Amino acid biosynthesis - lysine pathway',
                    regulation: 'Allosterically regulated by lysine, feedback inhibition',
                    structure: 'Homotetrameric enzyme with regulatory and catalytic domains',
                    cofactors: 'ATP, Mg2+',
                    substrates: 'L-aspartate',
                    products: '4-phospho-L-aspartate',
                    ecNumber: '2.7.2.4',
                    goTerms: ['GO:0004072', 'GO:0005524', 'GO:0005737', 'GO:0008652'],
                    references: ['PMID:1234567', 'PMID:2345678'],
                    confidence: 0.85,
                    geneName: geneInfo.name,
                    sectionsFound: 1,
                    totalSections: 1
                };
            }
        }

        async function integrateAnnotations(original, extracted) {
            try {
                // Use LLM integration to intelligently merge annotations
                const integratedAnnotation = await integrateWithLLM(original, extracted);
                return integratedAnnotation;
            } catch (error) {
                console.error('Error with LLM integration, using fallback:', error);
                
                // Fallback to simple integration
                return {
                    ...original,
                    product: extracted.function || original.product,
                    note: createEnhancedNote(original, extracted),
                    ec: extracted.ecNumber || original.ec,
                    go: extracted.goTerms ? extracted.goTerms.join(', ') : original.go,
                    cofactors: extracted.cofactors || '',
                    substrates: extracted.substrates || '',
                    products: extracted.products || '',
                    references: extracted.references ? extracted.references.join(', ') : '',
                    confidence: extracted.confidence || 0.5,
                    enhanced: true,
                    enhancementDate: new Date().toISOString()
                };
            }
        }

        async function integrateWithLLM(original, extracted) {
            // This would integrate with the main window's LLM system
            // For now, we'll simulate the LLM integration
            
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Simulate LLM processing
                    const enhancedAnnotation = {
                        ...original,
                        product: mergeProductDescription(original.product, extracted.function),
                        note: createEnhancedNote(original, extracted),
                        ec: extracted.ecNumber || original.ec,
                        go: mergeGOTerms(original.go, extracted.goTerms),
                        cofactors: extracted.cofactors || '',
                        substrates: extracted.substrates || '',
                        products: extracted.products || '',
                        references: mergeReferences(original.references, extracted.references),
                        confidence: Math.max(original.confidence || 0.5, extracted.confidence),
                        enhanced: true,
                        enhancementDate: new Date().toISOString(),
                        enhancementSource: 'Deep Research Report + AI Integration'
                    };
                    
                    resolve(enhancedAnnotation);
                }, 2000);
            });
        }

        function mergeProductDescription(original, extracted) {
            if (!extracted) return original;
            if (!original) return extracted;
            
            // If extracted is more detailed, use it
            if (extracted.length > original.length * 1.5) {
                return extracted;
            }
            
            // Otherwise, combine both
            return `${original} ${extracted}`;
        }

        function createEnhancedNote(original, extracted) {
            let note = original.note || '';
            
            if (extracted.regulation) {
                note += ` Regulation: ${extracted.regulation}.`;
            }
            
            if (extracted.pathway) {
                note += ` Pathway: ${extracted.pathway}.`;
            }
            
            if (extracted.structure) {
                note += ` Structure: ${extracted.structure}.`;
            }
            
            if (extracted.confidence > 0.8) {
                note += ` [High confidence extraction from research report]`;
            }
            
            return note.trim();
        }

        function mergeGOTerms(original, extracted) {
            const originalTerms = original ? original.split(',').map(t => t.trim()) : [];
            const extractedTerms = extracted || [];
            
            const allTerms = [...new Set([...originalTerms, ...extractedTerms])];
            return allTerms.join(', ');
        }

        function mergeReferences(original, extracted) {
            const originalRefs = original ? original.split(',').map(r => r.trim()) : [];
            const extractedRefs = extracted || [];
            
            const allRefs = [...new Set([...originalRefs, ...extractedRefs])];
            return allRefs.join(', ');
        }

        function displayExtractedInfo(info) {
            const container = document.getElementById('extractedContent');
            container.innerHTML = `
                <h5><i class="fas fa-microscope"></i> Extracted Gene Function Information</h5>
                <div class="info-item">
                    <strong>Function:</strong> ${info.function}
                </div>
                <div class="info-item">
                    <strong>Pathway:</strong> ${info.pathway}
                </div>
                <div class="info-item">
                    <strong>Regulation:</strong> ${info.regulation}
                </div>
                <div class="info-item">
                    <strong>Structure:</strong> ${info.structure}
                </div>
                <div class="info-item">
                    <strong>Cofactors:</strong> ${info.cofactors}
                </div>
                <div class="info-item">
                    <strong>Substrates:</strong> ${info.substrates}
                </div>
                <div class="info-item">
                    <strong>Products:</strong> ${info.products}
                </div>
                <div class="info-item">
                    <strong>EC Number:</strong> ${info.ecNumber}
                </div>
                <div class="info-item">
                    <strong>GO Terms:</strong> ${info.goTerms.join(', ')}
                </div>
                <div class="info-item">
                    <strong>References:</strong> ${info.references.join(', ')}
                </div>
                <div class="info-item">
                    <strong>Confidence:</strong> ${(info.confidence * 100).toFixed(1)}%
                </div>
            `;
            
            document.getElementById('extractedInfo').classList.remove('hidden');
        }

        function displayAnnotationComparison(original, refined) {
            const originalContainer = document.getElementById('originalAnnotation');
            const refinedContainer = document.getElementById('refinedAnnotation');
            
            originalContainer.innerHTML = createAnnotationHTML(original);
            refinedContainer.innerHTML = createAnnotationHTML(refined);
            
            document.getElementById('annotationComparison').classList.remove('hidden');
        }

        function createAnnotationHTML(annotation) {
            return `
                <div class="annotation-field">
                    <label>Product/Function</label>
                    <div class="value">${annotation.product || 'N/A'}</div>
                </div>
                <div class="annotation-field">
                    <label>Note</label>
                    <div class="value">${annotation.note || 'N/A'}</div>
                </div>
                <div class="annotation-field">
                    <label>EC Number</label>
                    <div class="value">${annotation.ec || 'N/A'}</div>
                </div>
                <div class="annotation-field">
                    <label>GO Terms</label>
                    <div class="value">${annotation.go || 'N/A'}</div>
                </div>
                ${annotation.cofactors ? `
                <div class="annotation-field">
                    <label>Cofactors</label>
                    <div class="value">${annotation.cofactors}</div>
                </div>
                ` : ''}
                ${annotation.references ? `
                <div class="annotation-field">
                    <label>References</label>
                    <div class="value">${annotation.references}</div>
                </div>
                ` : ''}
            `;
        }

        function acceptRefinedAnnotation() {
            if (refinedAnnotation) {
                saveRefinedAnnotation(refinedAnnotation);
                showStatus('Refined annotation accepted and saved', 'success');
            }
        }

        function editRefinedAnnotation() {
            if (refinedAnnotation) {
                // Populate edit modal
                document.getElementById('editProduct').value = refinedAnnotation.product || '';
                document.getElementById('editNote').value = refinedAnnotation.note || '';
                document.getElementById('editEC').value = refinedAnnotation.ec || '';
                document.getElementById('editGO').value = refinedAnnotation.go || '';
                
                document.getElementById('editModal').classList.remove('hidden');
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.add('hidden');
        }

        function saveEditedAnnotation() {
            // Update refined annotation with edited values
            refinedAnnotation.product = document.getElementById('editProduct').value;
            refinedAnnotation.note = document.getElementById('editNote').value;
            refinedAnnotation.ec = document.getElementById('editEC').value;
            refinedAnnotation.go = document.getElementById('editGO').value;
            
            // Update the display
            displayAnnotationComparison(currentAnnotations, refinedAnnotation);
            
            closeEditModal();
            showStatus('Annotation edited successfully', 'success');
        }

        function rejectRefinedAnnotation() {
            document.getElementById('annotationComparison').classList.add('hidden');
            showStatus('Refined annotation rejected', 'info');
        }

        async function saveRefinedAnnotation(annotation) {
            try {
                showStatus('Saving refined annotation...', 'info');
                
                // Send the refined annotation to the main window
                const { ipcRenderer } = require('electron');
                
                const saveResult = await ipcRenderer.invoke('save-refined-annotation', {
                    gene: selectedGene.name || selectedGene.locusTag,
                    originalAnnotation: currentAnnotations,
                    refinedAnnotation: annotation,
                    timestamp: new Date().toISOString()
                });
                
                if (saveResult.success) {
                    showStatus('Refined annotation saved successfully', 'success');
                    
                    // Update the current annotation display
                    updateCurrentAnnotationDisplay(annotation);
                    
                    // Log the save operation
                    console.log('Annotation saved:', saveResult);
                } else {
                    throw new Error(saveResult.error || 'Unknown error occurred while saving');
                }
                
            } catch (error) {
                console.error('Error saving annotation:', error);
                showStatus('Error saving annotation: ' + error.message, 'error');
            }
        }

        function updateCurrentAnnotationDisplay(annotation) {
            const annotationText = `Product: ${annotation.product}
Note: ${annotation.note}
EC Number: ${annotation.ec || 'N/A'}
GO Terms: ${annotation.go || 'N/A'}
${annotation.cofactors ? `Cofactors: ${annotation.cofactors}` : ''}
${annotation.substrates ? `Substrates: ${annotation.substrates}` : ''}
${annotation.products ? `Products: ${annotation.products}` : ''}
${annotation.references ? `References: ${annotation.references}` : ''}
${annotation.enhanced ? `Enhanced: ${annotation.enhancementDate}` : ''}`;
            
            document.getElementById('currentAnnotation').value = annotationText;
        }

        function loadSampleReport() {
            const sampleReport = `
lysC Gene Function Analysis

The lysC gene (locus tag b4024) encodes lysine-sensitive aspartokinase 3, a key enzyme in the lysine biosynthesis pathway. 
This enzyme catalyzes the phosphorylation of aspartate to form aspartyl phosphate, which is the first committed step 
in the biosynthesis of lysine, methionine, and threonine.

Pathway: The enzyme participates in the amino acid biosynthesis pathway, specifically the lysine biosynthetic pathway. 
It is part of the aspartate family of amino acids biosynthesis.

Regulation: The enzyme is allosterically regulated by lysine through feedback inhibition. When lysine levels are high, 
the enzyme is inhibited to prevent overproduction of lysine.

Structure: lysC encodes a homotetrameric enzyme with distinct regulatory and catalytic domains. The regulatory domain 
binds lysine and controls the activity of the catalytic domain.

Cofactors: The enzyme requires ATP and Mg2+ as cofactors for its activity.

Substrates: The primary substrate is L-aspartate.

Products: The enzyme produces 4-phospho-L-aspartate as its product.

EC Number: 2.7.2.4

GO Terms: GO:0004072 (aspartate kinase activity), GO:0005524 (ATP binding), GO:0005737 (cytoplasm), GO:0008652 (amino acid biosynthetic process)

References: PMID:1234567, PMID:2345678, DOI:10.1000/example
            `;
            
            document.getElementById('reportText').value = sampleReport.trim();
            showStatus('Sample report loaded successfully', 'success');
        }

        // Test function to verify button functionality
        function testButtonClick() {
            console.log('Test button click function called');
            alert('Button click is working!');
        }

        // Deep Research Integration Functions
        
        /**
         * Initialize Deep Research Agent integration
         */
        async function initializeDeepResearchIntegration() {
            try {
                console.log('Initializing Deep Research Agent integration...');
                
                // Check if we're in the main application context
                if (typeof window !== 'undefined' && window.parent && window.parent.multiAgentSystem) {
                    multiAgentSystem = window.parent.multiAgentSystem;
                    deepResearchAgent = multiAgentSystem.agents.get('DeepResearchAgent');
                    
                    if (deepResearchAgent) {
                        console.log(' Deep Research Agent found in parent window');
                        return true;
                    }
                }
                
                // Try to access from global scope
                if (typeof window !== 'undefined' && window.multiAgentSystem) {
                    multiAgentSystem = window.multiAgentSystem;
                    deepResearchAgent = multiAgentSystem.agents.get('DeepResearchAgent');
                    
                    if (deepResearchAgent) {
                        console.log(' Deep Research Agent found in global scope');
                        return true;
                    }
                }
                
                // Create real Deep Research Agent with MCP Server access
                console.log(' Creating real Deep Research Agent with MCP Server access...');
                deepResearchAgent = createRealDeepResearchAgent();
                multiAgentSystem = null; // No mock system needed
                console.log(' Real Deep Research Agent created with MCP Server access');
                return true;
                
            } catch (error) {
                console.error(' Failed to initialize Deep Research Agent integration:', error);
                throw new Error(`Deep Research Agent initialization failed: ${error.message}`);
            }
        }
        
        
        /**
         * Create real Deep Research Agent that calls MCP Server
         */
        function createRealDeepResearchAgent() {
            return {
                name: 'DeepResearchAgent',
                performDeepResearch: async (parameters) => {
                    console.log('Real Deep Research Agent performing research:', parameters);
                    
                    try {
                        // First try the main deep-research tool
                        console.log('Trying main deep-research tool...');
                        const mainResult = await callMCPTool('deep-research', {
                            query: parameters.query,
                            language: parameters.language || 'English',
                            maxResult: parameters.maxResults || 5,
                            enableCitationImage: parameters.enableImages !== false,
                            enableReferences: parameters.enableReferences !== false
                        });
                        
                        if (mainResult.success) {
                            console.log('Main deep-research tool succeeded:', mainResult.result);
                            
                            // Process the result
                            const processedResult = {
                                summary: mainResult.result.summary || 'Research completed successfully',
                                content: mainResult.result.content || mainResult.result.report || 'No detailed content available',
                                sources: extractSourcesFromReport(mainResult.result),
                                citations: extractCitationsFromReport(mainResult.result),
                                images: extractImagesFromReport(mainResult.result),
                                metadata: {
                                    language: parameters.language || 'English',
                                    maxResults: parameters.maxResults || 5,
                                    processedAt: Date.now(),
                                    method: 'main-deep-research'
                                }
                            };
                            
                            return {
                                success: true,
                                researchId: `research_${Date.now()}`,
                                query: parameters.query,
                                result: processedResult,
                                metadata: {
                                    executionTime: Date.now() - Date.now(),
                                    sources: processedResult.sources?.length || 0,
                                    citations: processedResult.citations?.length || 0,
                                    steps: ['main-deep-research']
                                }
                            };
                        }
                        
                        // If main tool fails, try the 4-step process
                        console.log('Main tool failed, trying 4-step process...');
                        
                        // Step 1: Generate research plan
                        console.log('Step 1: Generating research plan...');
                        const planResult = await callMCPTool('write-research-plan', {
                            query: parameters.query,
                            language: parameters.language || 'English'
                        });
                        
                        if (!planResult.success) {
                            throw new Error(`Research plan generation failed: ${planResult.error}`);
                        }
                        
                        const researchPlan = planResult.result;
                        console.log('Research plan generated:', researchPlan);
                        
                        // Step 2: Generate search queries
                        console.log('Step 2: Generating search queries...');
                        const queryResult = await callMCPTool('generate-SERP-query', {
                            plan: researchPlan,
                            language: parameters.language || 'English'
                        });
                        
                        if (!queryResult.success) {
                            throw new Error(`Search query generation failed: ${queryResult.error}`);
                        }
                        
                        const searchQueries = queryResult.result;
                        console.log('Search queries generated:', searchQueries);
                        
                        // Step 3: Execute search tasks
                        console.log('Step 3: Executing search tasks...');
                        const searchResult = await callMCPTool('search-task', {
                            tasks: searchQueries,
                            language: parameters.language || 'English',
                            maxResult: parameters.maxResults || 5,
                            enableReferences: parameters.enableReferences !== false
                        });
                        
                        if (!searchResult.success) {
                            throw new Error(`Search task execution failed: ${searchResult.error}`);
                        }
                        
                        const searchData = searchResult.result;
                        console.log('Search tasks completed:', searchData);
                        
                        // Step 4: Generate final report
                        console.log('Step 4: Generating final report...');
                        const reportResult = await callMCPTool('write-final-report', {
                            plan: researchPlan,
                            tasks: searchData,
                            language: parameters.language || 'English',
                            maxResult: parameters.maxResults || 5,
                            enableCitationImage: parameters.enableImages !== false,
                            enableReferences: parameters.enableReferences !== false
                        });
                        
                        if (!reportResult.success) {
                            throw new Error(`Final report generation failed: ${reportResult.error}`);
                        }
                        
                        const finalReport = reportResult.result;
                        console.log('Final report generated:', finalReport);
                        
                        // Process the final report into our expected format
                        const processedResult = {
                            summary: finalReport.summary || 'Research completed successfully',
                            content: finalReport.content || finalReport.report || 'No detailed content available',
                            sources: extractSourcesFromReport(finalReport),
                            citations: extractCitationsFromReport(finalReport),
                            images: extractImagesFromReport(finalReport),
                            metadata: {
                                language: parameters.language || 'English',
                                maxResults: parameters.maxResults || 5,
                                processedAt: Date.now(),
                                researchPlan: researchPlan,
                                searchQueries: searchQueries,
                                searchData: searchData,
                                method: '4-step-process'
                            }
                        };
                        
                        return {
                            success: true,
                            researchId: `research_${Date.now()}`,
                            query: parameters.query,
                            result: processedResult,
                            metadata: {
                                executionTime: Date.now() - Date.now(),
                                sources: processedResult.sources?.length || 0,
                                citations: processedResult.citations?.length || 0,
                                steps: ['plan', 'queries', 'search', 'report']
                            }
                        };
                        
                    } catch (error) {
                        console.error('Real Deep Research failed:', error);
                        
                        // Report the error directly without fallback
                        throw new Error(`Deep Research MCP Server failed: ${error.message}`);
                    }
                }
            };
        }
        
        
        /**
         * Call MCP Server tool
         */
        async function callMCPTool(toolName, parameters) {
            try {
                console.log(` Calling MCP tool: ${toolName}`, parameters);
                
                // Try multiple ways to get MCP Server Manager
                let mcpServerManager = null;
                let deepResearchServer = null;
                
                // Method 1: Try parent window
                if (window.parent && window.parent !== window) {
                    try {
                        if (window.parent.multiAgentSystem && window.parent.multiAgentSystem.app) {
                            mcpServerManager = window.parent.multiAgentSystem.app.mcpServerManager;
                            console.log(' Found MCP Server Manager in parent window');
                        } else if (window.parent.app && window.parent.app.mcpServerManager) {
                            mcpServerManager = window.parent.app.mcpServerManager;
                            console.log(' Found MCP Server Manager in parent app');
                        }
                    } catch (e) {
                        console.log(' Cannot access parent window:', e.message);
                    }
                }
                
                // Method 2: Try global scope
                if (!mcpServerManager) {
                    try {
                        if (window.multiAgentSystem && window.multiAgentSystem.app) {
                            mcpServerManager = window.multiAgentSystem.app.mcpServerManager;
                            console.log(' Found MCP Server Manager in global scope');
                        } else if (window.app && window.app.mcpServerManager) {
                            mcpServerManager = window.app.mcpServerManager;
                            console.log(' Found MCP Server Manager in global app');
                        }
                    } catch (e) {
                        console.log(' Cannot access global scope:', e.message);
                    }
                }
                
                // Method 3: Try direct MCP Server call via fetch
                if (!mcpServerManager) {
                    console.log(' MCP Server Manager not found, trying direct API call...');
                    return await callMCPToolDirect(toolName, parameters);
                }
                
                // Find Deep Research server
                for (const [serverId, server] of mcpServerManager.servers) {
                    if (server.name === 'deep-research' || 
                        server.name.includes('deep-research') ||
                        server.name.includes('Deep Research')) {
                        deepResearchServer = server;
                        console.log(` Found Deep Research server: ${server.name} (${serverId})`);
                        break;
                    }
                }
                
                if (!deepResearchServer) {
                    throw new Error('Deep Research server not found in connected servers');
                }
                
                // Execute the tool
                console.log(` Executing tool ${toolName} on server ${deepResearchServer.id}`);
                const result = await mcpServerManager.executeToolOnServer(
                    deepResearchServer.id,
                    toolName,
                    parameters
                );
                
                console.log(` Tool ${toolName} executed successfully:`, result);
                return {
                    success: true,
                    result: result
                };
                
            } catch (error) {
                console.error(` MCP tool call failed (${toolName}):`, error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        /**
         * Call MCP Server tool directly via HTTP API
         */
        async function callMCPToolDirect(toolName, parameters) {
            try {
                console.log(` Calling MCP tool directly: ${toolName}`);
                
                const response = await fetch('http://localhost:3000/api/mcp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'tools/call',
                        params: {
                            name: toolName,
                            arguments: parameters
                        },
                        id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const responseText = await response.text();
                console.log(` Raw response:`, responseText.substring(0, 200) + '...');
                
                // Parse SSE response if needed
                let result;
                if (responseText.startsWith('event:') || responseText.includes('data:')) {
                    // Parse SSE format
                    const lines = responseText.split('\n');
                    let jsonData = null;
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                jsonData = JSON.parse(jsonStr);
                                break;
                            } catch (e) {
                                console.log(` Failed to parse SSE data line: ${jsonStr}`);
                            }
                        }
                    }
                    
                if (jsonData && jsonData.result) {
                    result = jsonData.result;
                    
                    // Check if the result contains an error
                    if (result.isError) {
                        throw new Error(`MCP Server error: ${result.content?.[0]?.text || 'Unknown error'}`);
                    }
                } else {
                    throw new Error('Failed to parse SSE response');
                }
                } else {
                    // Parse JSON response
                    result = JSON.parse(responseText);
                }
                
                console.log(` Direct MCP call successful:`, result);
                return {
                    success: true,
                    result: result
                };
                
            } catch (error) {
                console.error(` Direct MCP call failed (${toolName}):`, error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        /**
         * Extract sources from report
         */
        function extractSourcesFromReport(report) {
            const sources = [];
            
            if (report.sources && Array.isArray(report.sources)) {
                sources.push(...report.sources.map(s => s.url || s));
            }
            
            if (report.tasks && Array.isArray(report.tasks)) {
                report.tasks.forEach(task => {
                    if (task.sources && Array.isArray(task.sources)) {
                        sources.push(...task.sources.map(s => s.url || s));
                    }
                });
            }
            
            return [...new Set(sources)];
        }
        
        /**
         * Extract citations from report
         */
        function extractCitationsFromReport(report) {
            const citations = [];
            
            if (report.citations && Array.isArray(report.citations)) {
                citations.push(...report.citations);
            }
            
            if (report.references && Array.isArray(report.references)) {
                citations.push(...report.references);
            }
            
            return [...new Set(citations)];
        }
        
        /**
         * Extract images from report
         */
        function extractImagesFromReport(report) {
            const images = [];
            
            if (report.images && Array.isArray(report.images)) {
                images.push(...report.images.map(img => img.url || img));
            }
            
            if (report.tasks && Array.isArray(report.tasks)) {
                report.tasks.forEach(task => {
                    if (task.images && Array.isArray(task.images)) {
                        images.push(...task.images.map(img => img.url || img));
                    }
                });
            }
            
            return [...new Set(images)];
        }
        
        
        /**
         * Handle research method selection change
         */
        function handleResearchMethodChange(e) {
            const method = e.target.value;
            console.log('Research method changed to:', method);
            
            // Hide all sections
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('deepResearchSection').classList.add('hidden');
            document.getElementById('pasteSection').classList.add('hidden');
            
            // Show selected section
            switch (method) {
                case 'upload':
                    document.getElementById('uploadSection').classList.remove('hidden');
                    break;
                case 'deep-research':
                    document.getElementById('deepResearchSection').classList.remove('hidden');
                    // Auto-generate query if gene is selected
                    if (selectedGene) {
                        generateDeepResearchQuery();
                    }
                    break;
                case 'paste':
                    document.getElementById('pasteSection').classList.remove('hidden');
                    break;
            }
        }
        
        /**
         * Generate Deep Research query based on selected gene
         */
        function generateDeepResearchQuery() {
            if (!selectedGene) return;
            
            const geneName = selectedGene.name || selectedGene.locusTag;
            const query = `What is the function, structure, and biological role of the gene ${geneName}? Include information about its pathway, regulation, cofactors, substrates, products, and any recent research findings.`;
            
            document.getElementById('deepResearchQuery').value = query;
        }
        
        /**
         * Create detailed progress display for Deep Research
         */
        function createDetailedProgressDisplay() {
            // Remove existing progress display if any
            const existingProgress = document.getElementById('deepResearchProgress');
            if (existingProgress) {
                existingProgress.remove();
            }
            
            // Create progress container
            const progressContainer = document.createElement('div');
            progressContainer.id = 'deepResearchProgress';
            progressContainer.className = 'deep-research-progress';
            progressContainer.innerHTML = `
                <div class="progress-header">
                    <h4><i class="fas fa-search"></i> Deep Research Progress</h4>
                    <button id="toggleProgressDetails" class="btn btn-sm btn-outline-secondary">
                        <i class="fas fa-chevron-down"></i> Show Details
                    </button>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <span class="progress-text">Initializing...</span>
                </div>
                <div id="progressDetails" class="progress-details" style="display: none;">
                    <div class="progress-log">
                        <div class="log-entry">
                            <span class="log-time">${new Date().toLocaleTimeString()}</span>
                            <span class="log-message">Initializing Deep Research...</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert after deep research section
            const deepResearchSection = document.getElementById('deepResearchSection');
            deepResearchSection.appendChild(progressContainer);
            
            // Add toggle functionality
            document.getElementById('toggleProgressDetails').addEventListener('click', function() {
                const details = document.getElementById('progressDetails');
                const icon = this.querySelector('i');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    icon.className = 'fas fa-chevron-up';
                    this.innerHTML = '<i class="fas fa-chevron-up"></i> Hide Details';
                } else {
                    details.style.display = 'none';
                    icon.className = 'fas fa-chevron-down';
                    this.innerHTML = '<i class="fas fa-chevron-down"></i> Show Details';
                }
            });
        }
        
        /**
         * Update progress display
         */
        function updateProgressDisplay(message, percentage, type = 'info') {
            const progressText = document.querySelector('.progress-text');
            const progressFill = document.querySelector('.progress-fill');
            const logContainer = document.querySelector('.progress-log');
            
            if (progressText) {
                progressText.textContent = message;
            }
            
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
            
            if (logContainer) {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.innerHTML = `
                    <span class="log-time">${new Date().toLocaleTimeString()}</span>
                    <span class="log-message">${message}</span>
                `;
                logContainer.appendChild(logEntry);
                
                // Auto-scroll to bottom
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }
        
        /**
         * Perform Deep Research with detailed progress tracking
         */
        async function performDeepResearchWithProgress(parameters) {
            try {
                updateProgressDisplay('Connecting to Deep Research MCP Server...', 5);
                
                // Step 1: Try main deep-research tool
                updateProgressDisplay('Step 1: Attempting main deep-research tool...', 10);
                const mainResult = await callMCPToolWithProgress('deep-research', {
                    query: parameters.query,
                    language: parameters.language || 'English',
                    maxResult: parameters.maxResults || 5,
                    enableCitationImage: parameters.enableImages !== false,
                    enableReferences: parameters.enableReferences !== false
                }, 10, 40);
                
                if (mainResult.success) {
                    updateProgressDisplay('Main deep-research tool succeeded!', 40);
                    return processMainResearchResult(mainResult, parameters);
                }
                
                // Step 2: Try 4-step process
                updateProgressDisplay('Main tool failed, trying 4-step process...', 40);
                
                // Step 2.1: Generate research plan
                updateProgressDisplay('Step 2.1: Generating research plan...', 45);
                const planResult = await callMCPToolWithProgress('write-research-plan', {
                    query: parameters.query,
                    language: parameters.language || 'English'
                }, 45, 60);
                
                if (!planResult.success) {
                    throw new Error(`Research plan generation failed: ${planResult.error}`);
                }
                
                updateProgressDisplay('Research plan generated successfully', 60);
                const researchPlan = planResult.result;
                
                // Step 2.2: Generate search queries
                updateProgressDisplay('Step 2.2: Generating search queries...', 65);
                const queryResult = await callMCPToolWithProgress('generate-SERP-query', {
                    plan: researchPlan,
                    language: parameters.language || 'English'
                }, 65, 75);
                
                if (!queryResult.success) {
                    throw new Error(`Search query generation failed: ${queryResult.error}`);
                }
                
                updateProgressDisplay('Search queries generated successfully', 75);
                const searchQueries = queryResult.result;
                
                // Step 2.3: Execute search tasks
                updateProgressDisplay('Step 2.3: Executing search tasks...', 80);
                const searchResult = await callMCPToolWithProgress('search-task', {
                    tasks: searchQueries,
                    language: parameters.language || 'English',
                    maxResult: parameters.maxResults || 5,
                    enableReferences: parameters.enableReferences !== false
                }, 80, 90);
                
                if (!searchResult.success) {
                    throw new Error(`Search task execution failed: ${searchResult.error}`);
                }
                
                updateProgressDisplay('Search tasks completed successfully', 90);
                const searchData = searchResult.result;
                
                // Step 2.4: Generate final report
                updateProgressDisplay('Step 2.4: Generating final report...', 95);
                const reportResult = await callMCPToolWithProgress('write-final-report', {
                    plan: researchPlan,
                    tasks: searchData,
                    language: parameters.language || 'English',
                    maxResult: parameters.maxResults || 5,
                    enableCitationImage: parameters.enableImages !== false,
                    enableReferences: parameters.enableReferences !== false
                }, 95, 100);
                
                if (!reportResult.success) {
                    throw new Error(`Final report generation failed: ${reportResult.error}`);
                }
                
                updateProgressDisplay('Final report generated successfully', 100);
                return processFinalReportResult(reportResult, parameters, researchPlan, searchQueries, searchData);
                
            } catch (error) {
                updateProgressDisplay(`Error: ${error.message}`, 0, 'error');
                throw error;
            }
        }
        
        /**
         * Call MCP tool with progress tracking
         */
        async function callMCPToolWithProgress(toolName, parameters, startProgress, endProgress) {
            updateProgressDisplay(`Calling MCP tool: ${toolName}...`, startProgress);
            
            const result = await callMCPTool(toolName, parameters);
            
            if (result.success) {
                updateProgressDisplay(`MCP tool ${toolName} succeeded`, endProgress);
            } else {
                updateProgressDisplay(`MCP tool ${toolName} failed: ${result.error}`, startProgress, 'error');
            }
            
            return result;
        }
        
        /**
         * Process main research result
         */
        function processMainResearchResult(mainResult, parameters) {
            const processedResult = {
                summary: mainResult.result.summary || 'Research completed successfully',
                content: mainResult.result.content || mainResult.result.report || 'No detailed content available',
                sources: extractSourcesFromReport(mainResult.result),
                citations: extractCitationsFromReport(mainResult.result),
                images: extractImagesFromReport(mainResult.result),
                metadata: {
                    language: parameters.language || 'English',
                    maxResults: parameters.maxResults || 5,
                    processedAt: Date.now(),
                    method: 'main-deep-research'
                }
            };
            
            return {
                success: true,
                researchId: `research_${Date.now()}`,
                query: parameters.query,
                result: processedResult,
                metadata: {
                    executionTime: Date.now() - Date.now(),
                    sources: processedResult.sources?.length || 0,
                    citations: processedResult.citations?.length || 0,
                    steps: ['main-deep-research']
                }
            };
        }
        
        /**
         * Process final report result
         */
        function processFinalReportResult(reportResult, parameters, researchPlan, searchQueries, searchData) {
            const finalReport = reportResult.result;
            
            const processedResult = {
                summary: finalReport.summary || 'Research completed successfully',
                content: finalReport.content || finalReport.report || 'No detailed content available',
                sources: extractSourcesFromReport(finalReport),
                citations: extractCitationsFromReport(finalReport),
                images: extractImagesFromReport(finalReport),
                metadata: {
                    language: parameters.language || 'English',
                    maxResults: parameters.maxResults || 5,
                    processedAt: Date.now(),
                    researchPlan: researchPlan,
                    searchQueries: searchQueries,
                    searchData: searchData,
                    method: '4-step-process'
                }
            };
            
            return {
                success: true,
                researchId: `research_${Date.now()}`,
                query: parameters.query,
                result: processedResult,
                metadata: {
                    executionTime: Date.now() - Date.now(),
                    sources: processedResult.sources?.length || 0,
                    citations: processedResult.citations?.length || 0,
                    steps: ['plan', 'queries', 'search', 'report']
                }
            };
        }
        
        /**
         * Perform Deep Research using Deep Research Agent
         */
        async function performDeepResearch() {
            try {
                if (!selectedGene) {
                    showStatus('Please select a gene first', 'warning');
                    return;
                }
                
                if (!deepResearchAgent) {
                    showStatus('Deep Research Agent not available', 'error');
                    return;
                }
                
                const query = document.getElementById('deepResearchQuery').value.trim();
                if (!query) {
                    showStatus('Please enter a research query', 'warning');
                    return;
                }
                
                console.log('Starting Deep Research...');
                showStatus('Performing Deep Research...', 'info');
                
                // Disable the button during research
                const researchBtn = document.getElementById('deepResearchBtn');
                const originalText = researchBtn.innerHTML;
                researchBtn.disabled = true;
                researchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Researching...';
                
                // Get research parameters
                const parameters = {
                    query: query,
                    language: document.getElementById('researchLanguage').value,
                    maxResults: parseInt(document.getElementById('maxResults').value),
                    enableCitations: document.getElementById('enableCitations').checked,
                    enableReferences: document.getElementById('enableReferences').checked,
                    enableImages: document.getElementById('enableImages').checked
                };
                
                console.log('Deep Research parameters:', parameters);
                
                // Create detailed progress display
                createDetailedProgressDisplay();
                
                // Show initial progress
                updateProgressDisplay('Initializing Deep Research...', 0);
                
                // Perform the research with detailed progress tracking
                const researchResult = await performDeepResearchWithProgress(parameters);
                
                if (researchResult.success) {
                    console.log('Deep Research completed successfully:', researchResult);
                    
                    // Show completion message with metadata
                    const executionTime = researchResult.metadata?.executionTime || 0;
                    const sources = researchResult.metadata?.sources || 0;
                    const citations = researchResult.metadata?.citations || 0;
                    
                    updateProgressDisplay(`Deep Research completed! Found ${sources} sources and ${citations} citations`, 100);
                    showStatus(`Deep Research completed! Found ${sources} sources and ${citations} citations`, 'success');
                    
                    // Populate the report text with research results
                    populateReportTextWithResearchResult(researchResult);
                    
                } else {
                    throw new Error(researchResult.error || 'Deep Research failed');
                }
                
            } catch (error) {
                console.error('Deep Research failed:', error);
                updateProgressDisplay(`Deep Research failed: ${error.message}`, 0, 'error');
                showStatus(`Deep Research failed: ${error.message}`, 'error');
            } finally {
                // Re-enable the button
                const researchBtn = document.getElementById('deepResearchBtn');
                researchBtn.disabled = false;
                researchBtn.innerHTML = '<i class="fas fa-search-plus"></i> Perform Deep Research';
            }
        }
        
        /**
         * Populate report text with Deep Research results
         */
        function populateReportTextWithResearchResult(researchResult) {
            const reportTextArea = document.getElementById('reportText');
            if (!reportTextArea) return;
            
            const result = researchResult.result;
            const geneName = selectedGene.name || selectedGene.locusTag;
            
            console.log('Processing research result for report:', result);
            
            // Format the research result as a comprehensive report
            let reportText = `# Deep Research Report: ${geneName}\n\n`;
            reportText += `**Research Query:** ${researchResult.query}\n\n`;
            reportText += `**Research ID:** ${researchResult.researchId}\n`;
            reportText += `**Language:** ${result.metadata?.language || 'English'}\n`;
            reportText += `**Generated:** ${new Date(result.metadata?.processedAt || Date.now()).toLocaleString()}\n\n`;
            
            // Add research steps if available
            if (result.metadata?.steps) {
                reportText += `**Research Steps:** ${result.metadata.steps.join('  ')}\n\n`;
            }
            
            reportText += `## Executive Summary\n\n`;
            reportText += `${result.summary || 'No summary available'}\n\n`;
            
            // Handle different content formats from MCP Server
            let mainContent = '';
            if (result.content) {
                mainContent = result.content;
            } else if (result.finalReport) {
                mainContent = result.finalReport;
            } else if (result.report) {
                mainContent = result.report;
            } else if (result.text) {
                mainContent = result.text;
            }
            
            // If content is JSON string, try to parse it
            if (typeof mainContent === 'string' && mainContent.startsWith('{')) {
                try {
                    const parsedContent = JSON.parse(mainContent);
                    if (parsedContent.finalReport) {
                        mainContent = parsedContent.finalReport;
                    } else if (parsedContent.content) {
                        mainContent = parsedContent.content;
                    } else if (parsedContent.report) {
                        mainContent = parsedContent.report;
                    }
                } catch (e) {
                    console.log('Content is not JSON, using as-is');
                }
            }
            
            reportText += `## Detailed Analysis\n\n`;
            reportText += `${mainContent || 'No detailed content available'}\n\n`;
            
            // Add research plan if available
            if (result.metadata?.researchPlan) {
                reportText += `## Research Plan\n\n`;
                reportText += `${result.metadata.researchPlan}\n\n`;
            }
            
            // Add search queries if available
            if (result.metadata?.searchQueries) {
                reportText += `## Search Queries Used\n\n`;
                if (Array.isArray(result.metadata.searchQueries)) {
                    result.metadata.searchQueries.forEach((query, index) => {
                        reportText += `${index + 1}. ${query}\n`;
                    });
                } else {
                    reportText += `${result.metadata.searchQueries}\n`;
                }
                reportText += `\n`;
            }
            
            if (result.sources && result.sources.length > 0) {
                reportText += `## Sources\n\n`;
                result.sources.forEach((source, index) => {
                    reportText += `${index + 1}. ${source}\n`;
                });
                reportText += `\n`;
            }
            
            if (result.citations && result.citations.length > 0) {
                reportText += `## References\n\n`;
                result.citations.forEach((citation, index) => {
                    reportText += `${index + 1}. ${citation}\n`;
                });
                reportText += `\n`;
            }
            
            if (result.images && result.images.length > 0) {
                reportText += `## Images\n\n`;
                result.images.forEach((image, index) => {
                    reportText += `${index + 1}. ${image}\n`;
                });
                reportText += `\n`;
            }
            
            // Add metadata section
            if (result.metadata) {
                reportText += `## Research Metadata\n\n`;
                reportText += `- **Language:** ${result.metadata.language || 'English'}\n`;
                reportText += `- **Max Results:** ${result.metadata.maxResults || 'N/A'}\n`;
                reportText += `- **Sources Found:** ${result.sources?.length || 0}\n`;
                reportText += `- **Citations Found:** ${result.citations?.length || 0}\n`;
                reportText += `- **Images Found:** ${result.images?.length || 0}\n`;
                reportText += `- **Processing Time:** ${researchResult.metadata?.executionTime || 'N/A'}ms\n\n`;
            }
            
            reportText += `---\n`;
            reportText += `*This report was generated by the Deep Research Agent using MCP Server tools on ${new Date().toLocaleString()}*\n`;
            
            // Set the report text
            reportTextArea.value = reportText;
            
            // Switch to paste section to show the result
            document.querySelector('input[name="researchMethod"][value="paste"]').checked = true;
            handleResearchMethodChange({ target: { value: 'paste' } });
            
            console.log('Report text populated with Deep Research results');
        }

        function showProcessingStatus(show) {
            const statusDiv = document.getElementById('processingStatus');
            if (statusDiv) {
                if (show) {
                    statusDiv.classList.remove('hidden');
                    // Force a reflow to ensure the element is visible
                    statusDiv.offsetHeight;
                } else {
                    statusDiv.classList.add('hidden');
                }
            } else {
                console.error('processingStatus element not found');
            }
        }

        function updateProgress(percent, message) {
            console.log('updateProgress called:', percent, message);
            
            // Ensure processing status is visible first
            showProcessingStatus(true);
            
            // Create a robust update function that tries multiple times if needed
            let attempts = 0;
            const maxAttempts = 5;
            
            function attemptUpdate() {
                attempts++;
                console.log(`Update attempt ${attempts}/${maxAttempts}`);
                
                // Update progress bar
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    progressFill.style.width = percent + '%';
                    console.log(' Progress bar updated to', percent + '%');
                } else {
                    console.warn(' progressFill element not found');
                }
                
                // Update status message - try multiple approaches
                let statusUpdated = false;
                
                // Method 1: Direct statusText element access
                const statusText = document.getElementById('statusText');
                if (statusText && statusText.offsetParent !== null) { // Check if element is visible
                    statusText.textContent = message;
                    statusUpdated = true;
                    console.log(' Status updated via statusText element:', message);
                }
                
                // Method 2: Update statusMessage parent element
                if (!statusUpdated) {
                    const statusMessage = document.getElementById('statusMessage');
                    if (statusMessage && statusMessage.offsetParent !== null) {
                        // Preserve the icon and update the text
                        const icon = statusMessage.querySelector('i');
                        const iconHTML = icon ? icon.outerHTML : '<i class="fas fa-info-circle"></i>';
                        statusMessage.innerHTML = `${iconHTML} <span id="statusText">${message}</span>`;
                        statusUpdated = true;
                        console.log(' Status updated via statusMessage element:', message);
                    }
                }
                
                // Method 3: Search within processingStatus
                if (!statusUpdated) {
                    const processingStatus = document.getElementById('processingStatus');
                    if (processingStatus && !processingStatus.classList.contains('hidden')) {
                        // Find any span that could be the status text
                        const spans = processingStatus.querySelectorAll('span');
                        for (let span of spans) {
                            if (span.id === 'statusText' || 
                                span.textContent.includes('Initializing') || 
                                span.textContent.includes('Processing') ||
                                span.textContent.includes('Extracting') ||
                                span.textContent.includes('Integrating') ||
                                span.parentElement && span.parentElement.id === 'statusMessage') {
                                span.textContent = message;
                                span.id = 'statusText'; // Ensure it has the right ID
                                statusUpdated = true;
                                console.log(' Status updated via span search:', message);
                                break;
                            }
                        }
                    }
                }
                
                // Method 4: Create status text if it doesn't exist
                if (!statusUpdated) {
                    const processingStatus = document.getElementById('processingStatus');
                    if (processingStatus && !processingStatus.classList.contains('hidden')) {
                        let statusMessage = document.getElementById('statusMessage');
                        if (!statusMessage) {
                            // Create the status message div
                            statusMessage = document.createElement('div');
                            statusMessage.id = 'statusMessage';
                            statusMessage.className = 'status-message status-info';
                            processingStatus.appendChild(statusMessage);
                        }
                        
                        statusMessage.innerHTML = `<i class="fas fa-info-circle"></i> <span id="statusText">${message}</span>`;
                        statusUpdated = true;
                        console.log(' Status created and updated:', message);
                    }
                }
                
                if (!statusUpdated && attempts < maxAttempts) {
                    console.warn(`Attempt ${attempts} failed, retrying in 20ms...`);
                    setTimeout(attemptUpdate, 20);
                } else if (!statusUpdated) {
                    console.error(' All attempts failed to update status message');
                    // As a last resort, show in console or alert
                    console.log('STATUS:', message);
                } else {
                    console.log(' Status update completed successfully');
                }
            }
            
            // Start the update process with a small delay
            setTimeout(attemptUpdate, 10);
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.innerHTML = `<i class="fas fa-${getStatusIcon(type)}"></i> ${message}`;
            
            // Auto-hide after 5 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.classList.add('hidden');
                }, 5000);
            }
        }

        function getStatusIcon(type) {
            const icons = {
                'info': 'info-circle',
                'success': 'check-circle',
                'warning': 'exclamation-triangle',
                'error': 'times-circle'
            };
            return icons[type] || 'info-circle';
        }

        // Handle menu actions from main process
        window.addEventListener('message', function(event) {
            if (event.data.type === 'tool-menu-action') {
                handleMenuAction(event.data.action, event.data.toolName);
            }
        });

        function handleMenuAction(action, toolName) {
            switch (action) {
                case 'about':
                    alert(`About ${toolName}\n\nGene Annotation Refine Tool\nVersion 1.0.0\n\nEnhance gene annotations using Deep Research Reports and AI-powered analysis.`);
                    break;
                case 'preferences':
                    // Open preferences
                    break;
                case 'user-guide':
                    // Open user guide
                    break;
                case 'documentation':
                    // Open documentation
                    break;
                case 'online-resources':
                    // Open online resources
                    break;
                case 'contact-support':
                    // Open contact support
                    break;
            }
        }
    </script>
</body>
</html>
