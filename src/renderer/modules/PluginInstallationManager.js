/**
 * PluginInstallationManager - Êèí‰ª∂Ëá™Âä®ÂÆâË£ÖÁÆ°ÁêÜÂô®
 * Ë¥üË¥£Êèí‰ª∂ÁöÑÂÆâË£Ö„ÄÅÊ≥®ÂÜå„ÄÅÊøÄÊ¥ªÂíåÁâàÊú¨ÁÆ°ÁêÜ
 */
class PluginInstallationManager {
    constructor(app) {
        this.app = app;
        this.pluginManagerV2 = app.pluginManagerV2 || window.pluginManagerV2;
        this.configManager = app.configManager;
        
        // ÂÆâË£ÖÈÖçÁΩÆ
        this.installConfig = {
            autoActivate: true,
            backupOriginals: true,
            validateBeforeInstall: true,
            allowOverwrite: false,
            sandboxMode: true
        };
        
        // ÂÆâË£ÖÁä∂ÊÄÅËøΩË∏™
        this.installations = new Map();
        this.installationHistory = [];
        this.activeInstallations = new Set();
        
        // Êñá‰ª∂Á≥ªÁªüÁÆ°ÁêÜ
        this.pluginsDirectory = '/plugins/';
        this.backupDirectory = '/plugins/.backup/';
        this.tempDirectory = '/plugins/.temp/';
        
        console.log('PluginInstallationManager initialized');
    }

    async initialize() {
        // ÂàõÂª∫ÂøÖË¶ÅÁöÑÁõÆÂΩïÁªìÊûÑ
        await this.createDirectoryStructure();
        
        // Ê£ÄÊü•Áé∞ÊúâÊèí‰ª∂
        await this.scanExistingPlugins();
        
        // ÂàùÂßãÂåñÁâàÊú¨ÁÆ°ÁêÜ
        await this.initializeVersionManagement();
        
        console.log('‚úÖ PluginInstallationManager ready');
    }

    /**
     * ÂÆâË£ÖÊèí‰ª∂
     */
    async installPlugin(codeGeneration, analysis) {
        try {
            console.log('üì¶ Starting plugin installation...');
            
            const installation = {
                installationId: this.generateInstallationId(),
                timestamp: Date.now(),
                startTime: performance.now(),
                
                // ÂÆâË£Ö‰ø°ÊÅØ
                pluginInfo: codeGeneration.pluginInfo,
                codeGeneration,
                analysis,
                
                // ÂÆâË£ÖÁä∂ÊÄÅ
                status: 'preparing',
                progress: 0,
                steps: [],
                
                // ÂÆâË£ÖÁªìÊûú
                installedFiles: [],
                registeredFunctions: [],
                errors: [],
                warnings: [],
                
                // ÂõûÊªö‰ø°ÊÅØ
                backupInfo: null,
                rollbackAvailable: false
            };
            
            this.installations.set(installation.installationId, installation);
            this.activeInstallations.add(installation.installationId);
            
            // Á¨¨1Ê≠•ÔºöÂáÜÂ§áÂÆâË£Ö (10%)
            installation.status = 'preparing';
            await this.prepareInstallation(installation);
            installation.progress = 10;
            this.updateInstallationProgress(installation);
            
            // Á¨¨2Ê≠•ÔºöÈ™åËØÅÊèí‰ª∂ (25%)
            if (this.installConfig.validateBeforeInstall) {
                installation.status = 'validating';
                await this.validateForInstallation(installation);
                installation.progress = 25;
                this.updateInstallationProgress(installation);
            }
            
            // Á¨¨3Ê≠•ÔºöÂ§á‰ªΩÁé∞ÊúâÊñá‰ª∂ (40%)
            if (this.installConfig.backupOriginals) {
                installation.status = 'backing_up';
                await this.createBackup(installation);
                installation.progress = 40;
                this.updateInstallationProgress(installation);
            }
            
            // Á¨¨4Ê≠•ÔºöÂÆâË£ÖÊñá‰ª∂ (60%)
            installation.status = 'installing';
            await this.installPluginFiles(installation);
            installation.progress = 60;
            this.updateInstallationProgress(installation);
            
            // Á¨¨5Ê≠•ÔºöÊ≥®ÂÜåÊèí‰ª∂ (80%)
            installation.status = 'registering';
            await this.registerPlugin(installation);
            installation.progress = 80;
            this.updateInstallationProgress(installation);
            
            // Á¨¨6Ê≠•ÔºöÊøÄÊ¥ªÊèí‰ª∂ (100%)
            if (this.installConfig.autoActivate) {
                installation.status = 'activating';
                await this.activatePlugin(installation);
                installation.progress = 100;
                this.updateInstallationProgress(installation);
            }
            
            // ÂÆåÊàêÂÆâË£Ö
            installation.status = 'completed';
            installation.endTime = performance.now();
            installation.duration = installation.endTime - installation.startTime;
            
            this.activeInstallations.delete(installation.installationId);
            this.installationHistory.push(installation);
            
            console.log(`‚úÖ Plugin installed successfully in ${installation.duration.toFixed(2)}ms`);
            
            return {
                success: true,
                installation,
                pluginInfo: installation.pluginInfo,
                installedAt: installation.timestamp,
                installationId: installation.installationId
            };
            
        } catch (error) {
            console.error('‚ùå Plugin installation failed:', error);
            
            if (installation) {
                installation.status = 'failed';
                installation.error = error.message;
                installation.endTime = performance.now();
                
                // Â∞ùËØïÂõûÊªö
                await this.attemptRollback(installation);
                
                this.activeInstallations.delete(installation.installationId);
            }
            
            throw error;
        }
    }

    /**
     * ÂáÜÂ§áÂÆâË£Ö
     */
    async prepareInstallation(installation) {
        const pluginInfo = installation.pluginInfo;
        
        // Ê£ÄÊü•Êèí‰ª∂IDÂÜ≤Á™Å
        if (await this.pluginExists(pluginInfo.id)) {
            if (!this.installConfig.allowOverwrite) {
                throw new Error(`Plugin ${pluginInfo.id} already exists. Set allowOverwrite to true to replace it.`);
            }
            installation.warnings.push('Existing plugin will be overwritten');
        }
        
        // Ê£ÄÊü•‰æùËµñ
        const dependencyCheck = await this.checkDependencies(pluginInfo.dependencies);
        if (!dependencyCheck.satisfied) {
            throw new Error(`Missing dependencies: ${dependencyCheck.missing.join(', ')}`);
        }
        
        // ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï
        installation.tempPath = `${this.tempDirectory}${pluginInfo.id}/`;
        await this.createDirectory(installation.tempPath);
        
        installation.steps.push({
            step: 'preparation',
            completed: Date.now(),
            success: true
        });
    }

    /**
     * È™åËØÅÂÆâË£ÖÂâçÁöÑÊèí‰ª∂
     */
    async validateForInstallation(installation) {
        const validation = {
            codeValid: false,
            structureValid: false,
            permissionsValid: false,
            securityPassed: false,
            issues: []
        };
        
        try {
            // ‰ª£Á†ÅËØ≠Ê≥ïÈ™åËØÅ
            new Function(installation.codeGeneration.mainCode);
            validation.codeValid = true;
        } catch (error) {
            validation.issues.push(`Code syntax error: ${error.message}`);
        }
        
        // Êèí‰ª∂ÁªìÊûÑÈ™åËØÅ
        const structureCheck = this.validatePluginStructure(installation.codeGeneration);
        validation.structureValid = structureCheck.valid;
        if (!structureCheck.valid) {
            validation.issues.push(...structureCheck.issues);
        }
        
        // ÊùÉÈôêÈ™åËØÅ
        const permissionCheck = await this.validatePermissions(installation.pluginInfo.permissions);
        validation.permissionsValid = permissionCheck.valid;
        if (!permissionCheck.valid) {
            validation.issues.push(...permissionCheck.issues);
        }
        
        // ÂÆâÂÖ®Ê£ÄÊü•
        const securityCheck = await this.performSecurityCheck(installation.codeGeneration.mainCode);
        validation.securityPassed = securityCheck.safe;
        if (!securityCheck.safe) {
            validation.issues.push(...securityCheck.issues);
        }
        
        if (validation.issues.length > 0) {
            throw new Error(`Validation failed: ${validation.issues.join('; ')}`);
        }
        
        installation.validationResults = validation;
        installation.steps.push({
            step: 'validation',
            completed: Date.now(),
            success: true,
            details: validation
        });
    }

    /**
     * ÂàõÂª∫Â§á‰ªΩ
     */
    async createBackup(installation) {
        const pluginId = installation.pluginInfo.id;
        const existingPlugin = await this.findExistingPlugin(pluginId);
        
        if (existingPlugin) {
            const backupId = `${pluginId}_backup_${Date.now()}`;
            const backupPath = `${this.backupDirectory}${backupId}/`;
            
            await this.createDirectory(backupPath);
            
            // Â§á‰ªΩÁé∞ÊúâÊèí‰ª∂Êñá‰ª∂
            const backupFiles = await this.copyPluginFiles(existingPlugin.path, backupPath);
            
            installation.backupInfo = {
                backupId,
                backupPath,
                originalPath: existingPlugin.path,
                backedUpFiles: backupFiles,
                timestamp: Date.now()
            };
            
            installation.rollbackAvailable = true;
            
            installation.steps.push({
                step: 'backup',
                completed: Date.now(),
                success: true,
                details: { backupId, fileCount: backupFiles.length }
            });
        }
    }

    /**
     * ÂÆâË£ÖÊèí‰ª∂Êñá‰ª∂
     */
    async installPluginFiles(installation) {
        const pluginId = installation.pluginInfo.id;
        const installPath = `${this.pluginsDirectory}${pluginId}/`;
        
        // ÂàõÂª∫Êèí‰ª∂ÁõÆÂΩï
        await this.createDirectory(installPath);
        
        const files = installation.codeGeneration.files || this.generateFileStructure(installation.codeGeneration);
        const installedFiles = [];
        
        for (const [filename, content] of Object.entries(files)) {
            try {
                const filePath = `${installPath}${filename}`;
                await this.writeFile(filePath, content);
                installedFiles.push({
                    filename,
                    path: filePath,
                    size: content.length,
                    timestamp: Date.now()
                });
            } catch (error) {
                installation.errors.push(`Failed to install ${filename}: ${error.message}`);
            }
        }
        
        installation.installedFiles = installedFiles;
        installation.installPath = installPath;
        
        installation.steps.push({
            step: 'file_installation',
            completed: Date.now(),
            success: installation.errors.length === 0,
            details: { fileCount: installedFiles.length, path: installPath }
        });
        
        if (installation.errors.length > 0) {
            throw new Error(`File installation failed: ${installation.errors.join('; ')}`);
        }
    }

    /**
     * Ê≥®ÂÜåÊèí‰ª∂
     */
    async registerPlugin(installation) {
        const pluginInfo = installation.pluginInfo;
        
        try {
            // Âä†ËΩΩÊèí‰ª∂‰ª£Á†Å
            const PluginClass = await this.loadPluginClass(installation);
            
            // ÂàõÂª∫Êèí‰ª∂ÂÆû‰æãËøõË°åÊµãËØï
            const testInstance = new PluginClass(this.createMockApp(), this.createMockAPI());
            await testInstance.initialize();
            
            // Âú®Êèí‰ª∂ÁÆ°ÁêÜÂô®‰∏≠Ê≥®ÂÜå
            if (this.pluginManagerV2) {
                const pluginDefinition = {
                    type: pluginInfo.type,
                    name: pluginInfo.name,
                    description: pluginInfo.description,
                    version: pluginInfo.version,
                    author: pluginInfo.author,
                    category: pluginInfo.category,
                    functions: this.extractFunctionDefinitions(installation),
                    permissions: pluginInfo.permissions,
                    dependencies: pluginInfo.dependencies,
                    enabled: true,
                    installPath: installation.installPath,
                    installationId: installation.installationId
                };
                
                await this.pluginManagerV2.registerPlugin(pluginInfo.id, pluginDefinition);
                
                installation.registeredFunctions = Object.keys(pluginDefinition.functions || {});
            }
            
            // Êõ¥Êñ∞Êèí‰ª∂Ê≥®ÂÜåË°®
            await this.updatePluginRegistry(pluginInfo.id, {
                ...pluginInfo,
                installPath: installation.installPath,
                installedAt: installation.timestamp,
                status: 'installed'
            });
            
            installation.steps.push({
                step: 'registration',
                completed: Date.now(),
                success: true,
                details: { functionsRegistered: installation.registeredFunctions.length }
            });
            
        } catch (error) {
            installation.errors.push(`Registration failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * ÊøÄÊ¥ªÊèí‰ª∂
     */
    async activatePlugin(installation) {
        try {
            const pluginId = installation.pluginInfo.id;
            
            // Âú®Êèí‰ª∂ÁÆ°ÁêÜÂô®‰∏≠ÊøÄÊ¥ª
            if (this.pluginManagerV2) {
                const plugin = this.pluginManagerV2.getPlugin(pluginId);
                if (plugin) {
                    plugin.enabled = true;
                    
                    // ÂàùÂßãÂåñÊèí‰ª∂
                    const PluginClass = await this.loadPluginClass(installation);
                    const pluginInstance = new PluginClass(this.app, this.createPluginAPI());
                    await pluginInstance.initialize();
                    
                    // Â≠òÂÇ®Êèí‰ª∂ÂÆû‰æãÂºïÁî®
                    installation.pluginInstance = pluginInstance;
                }
            }
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            await this.updatePluginStatus(pluginId, 'active');
            
            installation.steps.push({
                step: 'activation',
                completed: Date.now(),
                success: true
            });
            
            console.log(`‚úÖ Plugin ${pluginId} activated successfully`);
            
        } catch (error) {
            installation.warnings.push(`Activation failed: ${error.message}`);
            // ÊøÄÊ¥ªÂ§±Ë¥•‰∏çÂ∫îËØ•ÂØºËá¥Êï¥‰∏™ÂÆâË£ÖÂ§±Ë¥•
        }
    }

    /**
     * Âç∏ËΩΩÊèí‰ª∂
     */
    async uninstallPlugin(pluginId) {
        try {
            console.log(`üóëÔ∏è Uninstalling plugin: ${pluginId}`);
            
            const plugin = await this.findExistingPlugin(pluginId);
            if (!plugin) {
                throw new Error(`Plugin ${pluginId} not found`);
            }
            
            // ÂÅúÁî®Êèí‰ª∂
            await this.deactivatePlugin(pluginId);
            
            // ‰ªéÊèí‰ª∂ÁÆ°ÁêÜÂô®‰∏≠Ê≥®ÈîÄ
            if (this.pluginManagerV2) {
                // ËøôÈáåÈúÄË¶ÅÊ∑ªÂä†Ê≥®ÈîÄÂäüËÉΩÂà∞PluginManagerV2
                console.log(`Unregistering plugin ${pluginId} from PluginManagerV2`);
            }
            
            // Âà†Èô§Êèí‰ª∂Êñá‰ª∂
            await this.removePluginFiles(plugin.path);
            
            // Êõ¥Êñ∞Ê≥®ÂÜåË°®
            await this.removeFromPluginRegistry(pluginId);
            
            console.log(`‚úÖ Plugin ${pluginId} uninstalled successfully`);
            
            return {
                success: true,
                pluginId,
                uninstalledAt: Date.now()
            };
            
        } catch (error) {
            console.error(`‚ùå Failed to uninstall plugin ${pluginId}:`, error);
            throw error;
        }
    }

    /**
     * ÂõûÊªöÂÆâË£Ö
     */
    async attemptRollback(installation) {
        if (!installation.rollbackAvailable || !installation.backupInfo) {
            console.log('No rollback information available');
            return false;
        }
        
        try {
            console.log('üîÑ Attempting installation rollback...');
            
            const backupInfo = installation.backupInfo;
            
            // Âà†Èô§Â∑≤ÂÆâË£ÖÁöÑÊñá‰ª∂
            if (installation.installPath) {
                await this.removeDirectory(installation.installPath);
            }
            
            // ÊÅ¢Â§çÂ§á‰ªΩÊñá‰ª∂
            await this.restoreFromBackup(backupInfo);
            
            console.log('‚úÖ Installation rollback completed');
            return true;
            
        } catch (error) {
            console.error('‚ùå Rollback failed:', error);
            return false;
        }
    }

    /**
     * ÁâàÊú¨ÁÆ°ÁêÜ
     */
    async updatePlugin(pluginId, newVersion) {
        try {
            console.log(`üîÑ Updating plugin ${pluginId} to version ${newVersion.version}`);
            
            const existingPlugin = await this.findExistingPlugin(pluginId);
            if (!existingPlugin) {
                throw new Error(`Plugin ${pluginId} not found`);
            }
            
            // ÂàõÂª∫Êõ¥Êñ∞Â§á‰ªΩ
            const backupResult = await this.createUpdateBackup(existingPlugin);
            
            // ÂÆâË£ÖÊñ∞ÁâàÊú¨
            const updateResult = await this.installPlugin(newVersion.codeGeneration, newVersion.analysis);
            
            // ËÆ∞ÂΩïÊõ¥Êñ∞ÂéÜÂè≤
            await this.recordUpdate(pluginId, {
                fromVersion: existingPlugin.version,
                toVersion: newVersion.version,
                updatedAt: Date.now(),
                backupId: backupResult.backupId,
                installationId: updateResult.installationId
            });
            
            return updateResult;
            
        } catch (error) {
            console.error(`‚ùå Plugin update failed:`, error);
            throw error;
        }
    }

    /**
     * ËæÖÂä©ÊñπÊ≥ï
     */
    generateFileStructure(codeGeneration) {
        const files = {};
        
        files['plugin.js'] = codeGeneration.mainCode;
        
        if (codeGeneration.manifestFile) {
            files['manifest.json'] = codeGeneration.manifestFile;
        }
        
        if (codeGeneration.packageJson) {
            files['package.json'] = codeGeneration.packageJson;
        }
        
        // Ê∑ªÂä†ÊµãËØïÊñá‰ª∂
        if (codeGeneration.testFiles) {
            Object.keys(codeGeneration.testFiles).forEach(filename => {
                files[`tests/${filename}`] = codeGeneration.testFiles[filename];
            });
        }
        
        // Ê∑ªÂä†ÊñáÊ°£Êñá‰ª∂
        if (codeGeneration.documentationFiles) {
            Object.keys(codeGeneration.documentationFiles).forEach(filename => {
                files[filename] = codeGeneration.documentationFiles[filename];
            });
        }
        
        return files;
    }

    async loadPluginClass(installation) {
        // Âú®ÂÆûÈôÖÁéØÂ¢É‰∏≠Âä†ËΩΩÊèí‰ª∂‰ª£Á†Å
        const code = installation.codeGeneration.mainCode;
        const className = this.extractClassName(code);
        
        // ÂàõÂª∫ÂÆâÂÖ®ÁöÑÊâßË°åÁéØÂ¢É
        const sandbox = this.createPluginSandbox();
        const func = new Function(...Object.keys(sandbox), code + `\nreturn ${className};`);
        
        return func(...Object.values(sandbox));
    }

    createPluginSandbox() {
        return {
            console: console,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            Promise: Promise,
            Date: Date,
            Math: Math,
            JSON: JSON,
            Object: Object,
            Array: Array,
            String: String,
            Number: Number,
            Boolean: Boolean,
            RegExp: RegExp,
            Error: Error
        };
    }

    extractClassName(code) {
        const match = code.match(/class\s+(\w+)/);
        return match ? match[1] : 'UnknownPlugin';
    }

    extractFunctionDefinitions(installation) {
        const functions = {};
        const pluginInfo = installation.pluginInfo;
        
        if (pluginInfo.functions) {
            pluginInfo.functions.forEach(func => {
                functions[func.suggestedName || func.pattern] = {
                    description: `${func.pattern} functionality`,
                    parameters: {
                        type: 'object',
                        properties: {},
                        required: []
                    },
                    execute: `this.${func.suggestedName || func.pattern}.bind(this)`
                };
            });
        }
        
        return functions;
    }

    createMockApp() {
        return {
            fileManager: {
                readFile: async () => 'mock content',
                writeFile: async () => true,
                exists: async () => true
            },
            trackRenderer: {
                addTrack: () => ({ id: 'mock-track' }),
                removeTrack: () => true
            }
        };
    }

    createMockAPI() {
        return {
            ui: {
                addMenuItem: () => ({ id: 'mock-menu' }),
                createPanel: () => ({
                    show: () => true,
                    hide: () => true
                })
            },
            data: {
                getCurrentGenome: () => ({ name: 'test-genome' }),
                getSelectedRegion: () => ({ chromosome: 'chr1', start: 1000, end: 2000 })
            },
            ai: {
                registerFunction: () => true
            }
        };
    }

    createPluginAPI() {
        // ËøîÂõûÂÆûÈôÖÁöÑÊèí‰ª∂API
        return {
            ui: this.app.uiManager || {},
            data: this.app.dataManager || {},
            ai: this.app.aiManager || {}
        };
    }

    async pluginExists(pluginId) {
        // Ê£ÄÊü•Êèí‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®
        return this.pluginManagerV2?.getPlugin(pluginId) !== null;
    }

    async checkDependencies(dependencies = []) {
        const missing = [];
        const satisfied = [];
        
        for (const dep of dependencies) {
            // Âú®ÂÆûÈôÖÂÆûÁé∞‰∏≠Ê£ÄÊü•‰æùËµñÊòØÂê¶ÂèØÁî®
            if (this.isDependencyAvailable(dep)) {
                satisfied.push(dep);
            } else {
                missing.push(dep);
            }
        }
        
        return {
            satisfied: missing.length === 0,
            missing,
            satisfied
        };
    }

    isDependencyAvailable(dependency) {
        // ÁÆÄÂåñÂÆûÁé∞ÔºåÂÆûÈôÖÂ∫îËØ•Ê£ÄÊü•ÂÖ∑‰ΩìÁöÑ‰æùËµñ
        const commonDependencies = ['d3', 'lodash', 'moment'];
        return commonDependencies.includes(dependency);
    }

    validatePluginStructure(codeGeneration) {
        const code = codeGeneration.mainCode;
        const issues = [];
        
        // Ê£ÄÊü•ÂøÖÈúÄÁöÑÂÖÉÁ¥†
        const required = ['class', 'constructor', 'initialize'];
        required.forEach(element => {
            if (!code.includes(element)) {
                issues.push(`Missing required element: ${element}`);
            }
        });
        
        return {
            valid: issues.length === 0,
            issues
        };
    }

    async validatePermissions(permissions = []) {
        // È™åËØÅÊùÉÈôêËØ∑Ê±ÇÊòØÂê¶ÂêàÁêÜ
        const validPermissions = [
            'file-access', 'network-access', 'genome-data', 
            'ui-modification', 'system-integration'
        ];
        
        const invalid = permissions.filter(p => !validPermissions.includes(p));
        
        return {
            valid: invalid.length === 0,
            issues: invalid.map(p => `Invalid permission: ${p}`)
        };
    }

    async performSecurityCheck(code) {
        const issues = [];
        
        // ÁÆÄÂçïÁöÑÂÆâÂÖ®Ê£ÄÊü•
        const dangerousPatterns = [
            { pattern: /eval\s*\(/g, message: 'eval() usage detected' },
            { pattern: /Function\s*\(/g, message: 'Function constructor usage detected' },
            { pattern: /document\.write/g, message: 'document.write usage detected' }
        ];
        
        dangerousPatterns.forEach(({ pattern, message }) => {
            if (pattern.test(code)) {
                issues.push(message);
            }
        });
        
        return {
            safe: issues.length === 0,
            issues
        };
    }

    // Êñá‰ª∂Á≥ªÁªüÊìç‰ΩúÊñπÊ≥ïÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
    async createDirectory(path) {
        console.log(`Creating directory: ${path}`);
        return true;
    }

    async removeDirectory(path) {
        console.log(`Removing directory: ${path}`);
        return true;
    }

    async writeFile(path, content) {
        console.log(`Writing file: ${path} (${content.length} bytes)`);
        return true;
    }

    async readFile(path) {
        console.log(`Reading file: ${path}`);
        return 'file content';
    }

    async copyPluginFiles(sourcePath, destPath) {
        console.log(`Copying files from ${sourcePath} to ${destPath}`);
        return ['plugin.js', 'manifest.json', 'package.json'];
    }

    async removePluginFiles(path) {
        console.log(`Removing plugin files at: ${path}`);
        return true;
    }

    async findExistingPlugin(pluginId) {
        // Êü•ÊâæÁé∞ÊúâÊèí‰ª∂
        if (this.pluginManagerV2) {
            const plugin = this.pluginManagerV2.getPlugin(pluginId);
            if (plugin) {
                return {
                    id: pluginId,
                    version: plugin.version,
                    path: plugin.installPath || `${this.pluginsDirectory}${pluginId}/`
                };
            }
        }
        return null;
    }

    async updatePluginRegistry(pluginId, pluginInfo) {
        console.log(`Updating plugin registry for: ${pluginId}`);
        return true;
    }

    async removeFromPluginRegistry(pluginId) {
        console.log(`Removing from plugin registry: ${pluginId}`);
        return true;
    }

    async updatePluginStatus(pluginId, status) {
        console.log(`Updating plugin status: ${pluginId} -> ${status}`);
        return true;
    }

    async deactivatePlugin(pluginId) {
        console.log(`Deactivating plugin: ${pluginId}`);
        
        if (this.pluginManagerV2) {
            const plugin = this.pluginManagerV2.getPlugin(pluginId);
            if (plugin) {
                plugin.enabled = false;
            }
        }
        
        return true;
    }

    async createDirectoryStructure() {
        const directories = [
            this.pluginsDirectory,
            this.backupDirectory,
            this.tempDirectory
        ];
        
        for (const dir of directories) {
            await this.createDirectory(dir);
        }
    }

    async scanExistingPlugins() {
        console.log('Scanning existing plugins...');
        // Âú®ÂÆûÈôÖÂÆûÁé∞‰∏≠Êâ´ÊèèÊèí‰ª∂ÁõÆÂΩï
        return [];
    }

    async initializeVersionManagement() {
        console.log('Initializing version management...');
        return true;
    }

    generateInstallationId() {
        return `install-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
    }

    updateInstallationProgress(installation) {
        console.log(`Installation progress: ${installation.progress}% (${installation.status})`);
    }

    getStats() {
        return {
            activeInstallations: this.activeInstallations.size,
            totalInstallations: this.installations.size,
            installationHistory: this.installationHistory.length,
            pluginsDirectory: this.pluginsDirectory
        };
    }

    async destroy() {
        this.installations.clear();
        this.installationHistory = [];
        this.activeInstallations.clear();
        console.log('‚úÖ PluginInstallationManager destroyed');
    }
}

// ÂØºÂá∫Á±ª
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PluginInstallationManager;
} else if (typeof window !== 'undefined') {
    window.PluginInstallationManager = PluginInstallationManager;
}