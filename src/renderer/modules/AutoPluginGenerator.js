/**
 * AutoPluginGenerator - 自动插件生成器
 * 根据对话分析结果自动生成符合系统要求的插件代码
 */
class AutoPluginGenerator {
    constructor(evolutionManager) {
        this.evolutionManager = evolutionManager;
        this.llmConfigManager = evolutionManager.llmConfigManager;
        
        // 插件模板
        this.pluginTemplates = this.initializePluginTemplates();
        this.codeTemplates = this.initializeCodeTemplates();
        
        console.log('AutoPluginGenerator initialized');
    }

    /**
     * 初始化插件模板
     */
    initializePluginTemplates() {
        return {
            genomics: {
                category: 'genomics-analysis',
                baseTemplate: 'genomic_analysis_plugin',
                commonFunctions: ['analyzeSequence', 'findFeatures', 'compareRegions'],
                parameters: ['chromosome', 'start', 'end', 'sequence']
            },
            proteomics: {
                category: 'protein-analysis',
                baseTemplate: 'protein_analysis_plugin',
                commonFunctions: ['analyzeStructure', 'predictFunction', 'findDomains'],
                parameters: ['sequence', 'structure', 'organism']
            },
            phylogenetics: {
                category: 'phylogenetic-analysis',
                baseTemplate: 'phylogenetic_plugin',
                commonFunctions: ['buildTree', 'calculateDistance', 'alignSequences'],
                parameters: ['sequences', 'method', 'model']
            },
            systems_biology: {
                category: 'network-analysis',
                baseTemplate: 'network_analysis_plugin',
                commonFunctions: ['buildNetwork', 'analyzeCentrality', 'findModules'],
                parameters: ['nodes', 'edges', 'networkType']
            },
            visualization: {
                category: 'visualization',
                baseTemplate: 'visualization_plugin',
                commonFunctions: ['renderPlot', 'createChart', 'exportImage'],
                parameters: ['data', 'plotType', 'options']
            }
        };
    }

    /**
     * 初始化代码模板
     */
    initializeCodeTemplates() {
        return {
            pluginStructure: `
/**
 * {{PLUGIN_NAME}} - {{PLUGIN_DESCRIPTION}}
 * Generated automatically by ConversationEvolutionManager
 */
class {{PLUGIN_CLASS_NAME}} {
    constructor(app, configManager) {
        this.app = app;
        this.configManager = configManager;
        console.log('{{PLUGIN_NAME}} initialized');
    }

    static getPluginInfo() {
        return {
            name: '{{PLUGIN_NAME}}',
            description: '{{PLUGIN_DESCRIPTION}}',
            version: '1.0.0',
            author: 'AutoGenerated',
            category: '{{PLUGIN_CATEGORY}}',
            functions: {
                {{FUNCTIONS_DEFINITIONS}}
            }
        };
    }

    {{FUNCTIONS_IMPLEMENTATIONS}}
}

// Plugin registration
if (typeof window !== 'undefined' && window.pluginManager) {
    const plugin = {{PLUGIN_CLASS_NAME}}.getPluginInfo();
    window.pluginManager.registerFunctionPlugin('{{PLUGIN_ID}}', plugin);
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {{PLUGIN_CLASS_NAME}};
} else if (typeof window !== 'undefined') {
    window.{{PLUGIN_CLASS_NAME}} = {{PLUGIN_CLASS_NAME}};
}`,

            functionDefinition: `
                {{FUNCTION_NAME}}: {
                    description: '{{FUNCTION_DESCRIPTION}}',
                    parameters: {
                        type: 'object',
                        properties: {
                            {{PARAMETERS_DEFINITION}}
                        },
                        required: [{{REQUIRED_PARAMETERS}}]
                    },
                    execute: this.{{FUNCTION_NAME}}.bind(this)
                }`,

            functionImplementation: `
    /**
     * {{FUNCTION_DESCRIPTION}}
     */
    async {{FUNCTION_NAME}}(params) {
        try {
            console.log('Executing {{FUNCTION_NAME}} with params:', params);
            
            // Parameter validation
            {{PARAMETER_VALIDATION}}
            
            // Main implementation
            {{MAIN_IMPLEMENTATION}}
            
            return {
                success: true,
                result: result,
                function: '{{FUNCTION_NAME}}',
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            console.error('{{FUNCTION_NAME}} error:', error);
            return {
                success: false,
                error: error.message,
                function: '{{FUNCTION_NAME}}',
                timestamp: new Date().toISOString()
            };
        }
    }`,

            parameterValidation: `
            if (!params.{{PARAM_NAME}}) {
                throw new Error('{{PARAM_NAME}} is required');
            }`,

            basicImplementation: `
            // Basic implementation for {{FUNCTION_NAME}}
            const result = {
                data: params,
                processed: true,
                type: '{{FUNCTION_TYPE}}',
                summary: 'Function executed successfully'
            };
            
            // TODO: Add specific implementation logic here`
        };
    }

    /**
     * 生成插件规格说明
     */
    async generatePluginSpecification(analysis) {
        try {
            const spec = {
                id: this.generatePluginId(analysis),
                name: this.generatePluginName(analysis),
                description: analysis.missingFunctionDescription,
                category: analysis.domain,
                functions: [],
                addresses: analysis.missingFunctionDescription,
                priority: analysis.priority,
                generationReason: analysis.category
            };

            // 生成函数规格
            const functions = await this.generateFunctionSpecs(analysis);
            spec.functions = functions;

            // 使用LLM增强规格说明
            if (this.llmConfigManager && this.llmConfigManager.isConfigured()) {
                const enhancedSpec = await this.enhanceSpecificationWithLLM(spec, analysis);
                if (enhancedSpec) {
                    return enhancedSpec;
                }
            }

            return spec;
        } catch (error) {
            console.error('Failed to generate plugin specification:', error);
            return null;
        }
    }

    /**
     * 生成插件ID
     */
    generatePluginId(analysis) {
        const domain = analysis.domain || 'general';
        const intent = analysis.userIntent || 'function';
        const timestamp = Date.now().toString(36);
        
        return `${domain}-${intent}-${timestamp}`.toLowerCase().replace(/[^a-z0-9-]/g, '-');
    }

    /**
     * 生成插件名称
     */
    generatePluginName(analysis) {
        const domain = analysis.domain || 'General';
        const intent = analysis.userIntent || 'Function';
        
        return `${domain.charAt(0).toUpperCase() + domain.slice(1)} ${intent.charAt(0).toUpperCase() + intent.slice(1)} Plugin`;
    }

    /**
     * 生成函数规格
     */
    async generateFunctionSpecs(analysis) {
        const functions = [];
        const template = this.pluginTemplates[analysis.domain] || this.pluginTemplates.general;
        
        // 基于用户意图生成主要函数
        const mainFunction = {
            name: this.generateFunctionName(analysis.userIntent),
            description: `Implements ${analysis.userIntent} functionality`,
            parameters: this.generateFunctionParameters(analysis),
            implementation: 'basic'
        };
        
        functions.push(mainFunction);

        // 添加辅助函数
        if (template) {
            const helperFunctions = this.generateHelperFunctions(analysis, template);
            functions.push(...helperFunctions);
        }

        return functions;
    }

    /**
     * 生成函数名称
     */
    generateFunctionName(intent) {
        const intentMap = {
            'gene_analysis': 'analyzeGenes',
            'protein_structure': 'analyzeProteinStructure',
            'phylogenetic_analysis': 'buildPhylogeneticTree',
            'network_analysis': 'analyzeNetwork',
            'data_visualization': 'visualizeData',
            'sequence_analysis': 'analyzeSequence'
        };

        return intentMap[intent] || 'executeFunction';
    }

    /**
     * 生成函数参数
     */
    generateFunctionParameters(analysis) {
        const domain = analysis.domain;
        const intent = analysis.userIntent;
        
        const parameterSets = {
            genomics: {
                type: 'object',
                properties: {
                    chromosome: { type: 'string', description: 'Chromosome identifier' },
                    start: { type: 'number', description: 'Start position' },
                    end: { type: 'number', description: 'End position' },
                    sequence: { type: 'string', description: 'DNA sequence' }
                },
                required: ['chromosome', 'start', 'end']
            },
            proteomics: {
                type: 'object',
                properties: {
                    sequence: { type: 'string', description: 'Protein sequence' },
                    organism: { type: 'string', description: 'Source organism' },
                    analysisType: { type: 'string', description: 'Type of analysis' }
                },
                required: ['sequence']
            },
            phylogenetics: {
                type: 'object',
                properties: {
                    sequences: { 
                        type: 'array', 
                        items: { type: 'string' },
                        description: 'Array of sequences to analyze' 
                    },
                    method: { type: 'string', description: 'Analysis method' },
                    model: { type: 'string', description: 'Evolutionary model' }
                },
                required: ['sequences']
            },
            systems_biology: {
                type: 'object',
                properties: {
                    nodes: { 
                        type: 'array',
                        description: 'Network nodes' 
                    },
                    edges: { 
                        type: 'array',
                        description: 'Network edges' 
                    },
                    analysisType: { type: 'string', description: 'Type of network analysis' }
                },
                required: ['nodes', 'edges']
            },
            visualization: {
                type: 'object',
                properties: {
                    data: { type: 'object', description: 'Data to visualize' },
                    plotType: { type: 'string', description: 'Type of plot' },
                    options: { type: 'object', description: 'Visualization options' }
                },
                required: ['data', 'plotType']
            }
        };

        return parameterSets[domain] || {
            type: 'object',
            properties: {
                data: { type: 'object', description: 'Input data' },
                options: { type: 'object', description: 'Function options' }
            },
            required: ['data']
        };
    }

    /**
     * 生成辅助函数
     */
    generateHelperFunctions(analysis, template) {
        const helperFunctions = [];
        
        // 验证函数
        helperFunctions.push({
            name: 'validateInput',
            description: 'Validate input parameters',
            parameters: {
                type: 'object',
                properties: {
                    input: { type: 'object', description: 'Input to validate' }
                },
                required: ['input']
            },
            implementation: 'validation'
        });

        // 结果格式化函数
        helperFunctions.push({
            name: 'formatResult',
            description: 'Format analysis result',
            parameters: {
                type: 'object',
                properties: {
                    rawResult: { type: 'object', description: 'Raw analysis result' }
                },
                required: ['rawResult']
            },
            implementation: 'formatting'
        });

        return helperFunctions;
    }

    /**
     * 使用LLM增强规格说明
     */
    async enhanceSpecificationWithLLM(spec, analysis) {
        try {
            const prompt = `作为生物信息学插件开发专家，请优化以下插件规格说明：

当前规格：
${JSON.stringify(spec, null, 2)}

原始分析：
- 用户意图：${analysis.userIntent}
- 领域：${analysis.domain}
- 缺失功能描述：${analysis.missingFunctionDescription}
- 建议实现：${analysis.suggestedImplementation}

请提供优化后的规格说明，包括：
1. 更准确的插件名称和描述
2. 完善的函数定义和参数
3. 适当的错误处理策略
4. 与现有GenomeExplorer插件系统的集成建议

请以JSON格式返回优化后的规格说明。`;

            const response = await this.llmConfigManager.sendMessageWithHistory([
                { role: 'user', content: prompt }
            ]);

            // 尝试解析LLM响应
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const enhancedSpec = JSON.parse(jsonMatch[0]);
                return { ...spec, ...enhancedSpec };
            }
        } catch (error) {
            console.warn('LLM specification enhancement failed:', error);
        }

        return spec;
    }

    /**
     * 生成插件代码
     */
    async generatePluginCode(spec) {
        try {
            // 生成基础插件结构
            let pluginCode = this.codeTemplates.pluginStructure;

            // 替换基础模板变量
            pluginCode = this.replaceTemplateVariables(pluginCode, {
                PLUGIN_NAME: spec.name,
                PLUGIN_DESCRIPTION: spec.description,
                PLUGIN_CLASS_NAME: this.generateClassName(spec.name),
                PLUGIN_CATEGORY: spec.category,
                PLUGIN_ID: spec.id
            });

            // 生成函数定义
            const functionsDefinitions = spec.functions.map(func => 
                this.generateFunctionDefinition(func)
            ).join(',');

            // 生成函数实现
            const functionsImplementations = spec.functions.map(func => 
                this.generateFunctionImplementation(func)
            ).join('\n');

            // 替换函数相关变量
            pluginCode = pluginCode.replace('{{FUNCTIONS_DEFINITIONS}}', functionsDefinitions);
            pluginCode = pluginCode.replace('{{FUNCTIONS_IMPLEMENTATIONS}}', functionsImplementations);

            // 使用LLM增强代码
            if (this.llmConfigManager && this.llmConfigManager.isConfigured()) {
                const enhancedCode = await this.enhanceCodeWithLLM(pluginCode, spec);
                if (enhancedCode) {
                    return enhancedCode;
                }
            }

            return pluginCode;
        } catch (error) {
            console.error('Failed to generate plugin code:', error);
            throw error;
        }
    }

    /**
     * 替换模板变量
     */
    replaceTemplateVariables(template, variables) {
        let result = template;
        for (const [key, value] of Object.entries(variables)) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            result = result.replace(regex, value);
        }
        return result;
    }

    /**
     * 生成类名
     */
    generateClassName(pluginName) {
        return pluginName
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join('') + 'Plugin';
    }

    /**
     * 生成函数定义
     */
    generateFunctionDefinition(func) {
        let definition = this.codeTemplates.functionDefinition;
        
        // 生成参数定义
        const paramDefs = Object.entries(func.parameters.properties || {})
            .map(([name, schema]) => {
                return `${name}: { type: '${schema.type}', description: '${schema.description}' }`;
            }).join(',\n                            ');

        const requiredParams = (func.parameters.required || [])
            .map(param => `'${param}'`)
            .join(', ');

        definition = this.replaceTemplateVariables(definition, {
            FUNCTION_NAME: func.name,
            FUNCTION_DESCRIPTION: func.description,
            PARAMETERS_DEFINITION: paramDefs,
            REQUIRED_PARAMETERS: requiredParams
        });

        return definition;
    }

    /**
     * 生成函数实现
     */
    generateFunctionImplementation(func) {
        let implementation = this.codeTemplates.functionImplementation;
        
        // 生成参数验证
        const validations = (func.parameters.required || [])
            .map(param => {
                return this.codeTemplates.parameterValidation
                    .replace(/{{PARAM_NAME}}/g, param);
            }).join('\n            ');

        // 生成主要实现
        const mainImpl = this.generateMainImplementation(func);

        implementation = this.replaceTemplateVariables(implementation, {
            FUNCTION_NAME: func.name,
            FUNCTION_DESCRIPTION: func.description,
            PARAMETER_VALIDATION: validations,
            MAIN_IMPLEMENTATION: mainImpl
        });

        return implementation;
    }

    /**
     * 生成主要实现代码
     */
    generateMainImplementation(func) {
        const implementationTypes = {
            basic: this.codeTemplates.basicImplementation,
            validation: `
            // Input validation implementation
            const isValid = this.validateInputData(params.input);
            const result = {
                valid: isValid,
                errors: isValid ? [] : ['Invalid input data'],
                validatedData: isValid ? params.input : null
            };`,
            formatting: `
            // Result formatting implementation
            const result = {
                formatted: true,
                originalData: params.rawResult,
                formattedData: this.formatData(params.rawResult),
                timestamp: new Date().toISOString()
            };`
        };

        const baseImpl = implementationTypes[func.implementation] || implementationTypes.basic;
        
        return this.replaceTemplateVariables(baseImpl, {
            FUNCTION_NAME: func.name,
            FUNCTION_TYPE: func.name.replace(/([A-Z])/g, '_$1').toLowerCase()
        });
    }

    /**
     * 使用LLM增强代码
     */
    async enhanceCodeWithLLM(code, spec) {
        try {
            const prompt = `作为JavaScript和生物信息学专家，请优化以下自动生成的插件代码：

插件规格：
${JSON.stringify(spec, null, 2)}

当前代码：
\`\`\`javascript
${code}
\`\`\`

请优化代码：
1. 改进函数实现，添加实际的生物信息学逻辑
2. 增强错误处理
3. 添加适当的文档注释
4. 确保与GenomeExplorer插件系统兼容
5. 添加输入验证和数据格式化

请返回完整的优化后的JavaScript代码。`;

            const response = await this.llmConfigManager.sendMessageWithHistory([
                { role: 'user', content: prompt }
            ]);

            // 提取代码块
            const codeMatch = response.match(/```javascript\n([\s\S]*?)\n```/);
            if (codeMatch) {
                return codeMatch[1];
            } else {
                // 如果没有代码块标记，尝试提取整个响应
                return response;
            }
        } catch (error) {
            console.warn('LLM code enhancement failed:', error);
        }

        return code;
    }

    /**
     * 验证生成的代码
     */
    validateGeneratedCode(code) {
        const validationResults = {
            syntaxValid: false,
            structureValid: false,
            pluginCompliant: false,
            issues: []
        };

        try {
            // 语法验证
            new Function(code);
            validationResults.syntaxValid = true;
        } catch (error) {
            validationResults.issues.push(`Syntax error: ${error.message}`);
        }

        // 结构验证
        const requiredElements = [
            'class', 'getPluginInfo', 'constructor', 'execute'
        ];
        
        const missingElements = requiredElements.filter(element => 
            !code.includes(element)
        );
        
        if (missingElements.length === 0) {
            validationResults.structureValid = true;
        } else {
            validationResults.issues.push(`Missing elements: ${missingElements.join(', ')}`);
        }

        // 插件兼容性验证
        const pluginRequirements = [
            'name:', 'description:', 'version:', 'functions:'
        ];
        
        const missingRequirements = pluginRequirements.filter(req => 
            !code.includes(req)
        );
        
        if (missingRequirements.length === 0) {
            validationResults.pluginCompliant = true;
        } else {
            validationResults.issues.push(`Missing plugin requirements: ${missingRequirements.join(', ')}`);
        }

        return validationResults;
    }

    /**
     * 生成插件测试代码
     */
    generateTestCode(spec) {
        const testTemplate = `
/**
 * Test suite for ${spec.name}
 */
class ${this.generateClassName(spec.name)}Test {
    constructor(plugin) {
        this.plugin = plugin;
        this.testResults = [];
    }
    
    async runAllTests() {
        console.log('Running tests for ${spec.name}...');
        
        ${spec.functions.map(func => `
        try {
            await this.test${func.name.charAt(0).toUpperCase() + func.name.slice(1)}();
        } catch (error) {
            this.addTestResult('${func.name}', false, error.message);
        }`).join('')}
        
        return this.testResults;
    }
    
    ${spec.functions.map(func => this.generateFunctionTest(func)).join('\n    ')}
    
    addTestResult(testName, success, message = '') {
        this.testResults.push({
            test: testName,
            success,
            message,
            timestamp: new Date().toISOString()
        });
    }
    
    generateSampleData() {
        return ${JSON.stringify(this.generateSampleTestData(spec), null, 8)};
    }
}
`;

        return testTemplate;
    }

    /**
     * 生成函数测试
     */
    generateFunctionTest(func) {
        return `
    async test${func.name.charAt(0).toUpperCase() + func.name.slice(1)}() {
        const sampleData = this.generateSampleData();
        const result = await this.plugin.${func.name}(sampleData.${func.name});
        
        if (result && result.success) {
            this.addTestResult('${func.name}', true, 'Function executed successfully');
        } else {
            this.addTestResult('${func.name}', false, result?.error || 'Function failed');
        }
    }`;
    }

    /**
     * 生成示例测试数据
     */
    generateSampleTestData(spec) {
        const sampleData = {};
        
        for (const func of spec.functions) {
            const funcData = {};
            
            for (const [paramName, paramSpec] of Object.entries(func.parameters.properties || {})) {
                switch (paramSpec.type) {
                    case 'string':
                        funcData[paramName] = 'sample_string';
                        break;
                    case 'number':
                        funcData[paramName] = 123;
                        break;
                    case 'array':
                        funcData[paramName] = ['item1', 'item2'];
                        break;
                    case 'object':
                        funcData[paramName] = { sample: 'object' };
                        break;
                    default:
                        funcData[paramName] = null;
                }
            }
            
            sampleData[func.name] = funcData;
        }
        
        return sampleData;
    }
}

// 导出类
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutoPluginGenerator;
} else if (typeof window !== 'undefined') {
    window.AutoPluginGenerator = AutoPluginGenerator;
}