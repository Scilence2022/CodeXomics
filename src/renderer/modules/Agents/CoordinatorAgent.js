/**
 * CoordinatorAgent - ÂçèË∞ÉÊô∫ËÉΩ‰Ωì
 * Ë¥üË¥£ÂçèË∞ÉÂÖ∂‰ªñÊô∫ËÉΩ‰ΩìÁöÑÂ∑•‰ΩúÔºåÂ§ÑÁêÜÂ§çÊùÇ‰ªªÂä°ÂàÜËß£ÂíåÁªìÊûúÊï¥Âêà
 */
class CoordinatorAgent extends AgentBase {
    constructor(multiAgentSystem) {
        super(multiAgentSystem, 'coordinator', [
            'task_coordination',
            'workflow_management',
            'result_integration',
            'error_recovery'
        ]);
        
        this.app = multiAgentSystem.app;
        this.configManager = multiAgentSystem.configManager;
        this.memorySystem = null;
        this.workflowEngine = null;
    }
    
    /**
     * ÊâßË°åÂÖ∑‰ΩìÂàùÂßãÂåñÈÄªËæë
     */
    async performInitialization() {
        // Á°Æ‰øùÂ∫îÁî®Â∑≤ÂàùÂßãÂåñ
        if (!this.app) {
            throw new Error('Application reference not available');
        }
        
        // Ëé∑ÂèñËÆ∞ÂøÜÁ≥ªÁªü
        this.memorySystem = this.app.memorySystem;
        
        // ÂàùÂßãÂåñÂ∑•‰ΩúÊµÅÂºïÊìé
        this.workflowEngine = new WorkflowEngine(this);
        
        console.log(`üéØ CoordinatorAgent: Coordination tools initialized`);
    }
    
    /**
     * Ê≥®ÂÜåÂ∑•ÂÖ∑Êò†Â∞Ñ
     */
    registerToolMapping() {
        // ‰ªªÂä°ÂçèË∞ÉÂ∑•ÂÖ∑
        this.toolMapping.set('coordinate_task', this.coordinateTask.bind(this));
        this.toolMapping.set('decompose_task', this.decomposeTask.bind(this));
        this.toolMapping.set('integrate_results', this.integrateResults.bind(this));
        
        // Â∑•‰ΩúÊµÅÁÆ°ÁêÜÂ∑•ÂÖ∑
        this.toolMapping.set('create_workflow', this.createWorkflow.bind(this));
        this.toolMapping.set('execute_workflow', this.executeWorkflow.bind(this));
        this.toolMapping.set('get_workflow_status', this.getWorkflowStatus.bind(this));
        
        // Êô∫ËÉΩ‰ΩìÂçèË∞ÉÂ∑•ÂÖ∑
        this.toolMapping.set('assign_task_to_agent', this.assignTaskToAgent.bind(this));
        this.toolMapping.set('get_agent_status', this.getAgentStatus.bind(this));
        this.toolMapping.set('balance_load', this.balanceLoad.bind(this));
        
        // ÈîôËØØÊÅ¢Â§çÂ∑•ÂÖ∑
        this.toolMapping.set('handle_error', this.handleError.bind(this));
        this.toolMapping.set('retry_failed_task', this.retryFailedTask.bind(this));
        this.toolMapping.set('fallback_strategy', this.fallbackStrategy.bind(this));
        
        // ÊÄßËÉΩ‰ºòÂåñÂ∑•ÂÖ∑
        this.toolMapping.set('optimize_execution', this.optimizeExecution.bind(this));
        this.toolMapping.set('cache_strategy', this.cacheStrategy.bind(this));
        this.toolMapping.set('parallel_execution', this.parallelExecution.bind(this));
        
        console.log(`üéØ CoordinatorAgent: Registered ${this.toolMapping.size} coordination tools`);
    }
    
    /**
     * ÂçèË∞É‰ªªÂä°
     */
    async coordinateTask(parameters, strategy) {
        try {
            const { task, priority = 'normal', timeout = 30000 } = parameters;
            
            if (!task) {
                throw new Error('Task is required');
            }
            
            // 1. ÂàÜÊûê‰ªªÂä°
            const taskAnalysis = await this.analyzeTask(task);
            
            // 2. ÂàÜËß£‰ªªÂä°
            const subtasks = await this.decomposeTask(taskAnalysis);
            
            // 3. ÂàÜÈÖç‰ªªÂä°ÁªôÊô∫ËÉΩ‰Ωì
            const assignments = await this.assignSubtasksToAgents(subtasks);
            
            // 4. ÊâßË°å‰ªªÂä°
            const results = await this.executeSubtasks(assignments, timeout);
            
            // 5. Êï¥ÂêàÁªìÊûú
            const integratedResult = await this.integrateResults(results);
            
            // 6. ËÆ∞ÂΩïÂà∞ËÆ∞ÂøÜÁ≥ªÁªü
            if (this.memorySystem) {
                await this.memorySystem.recordToolCall('coordinate_task', parameters, integratedResult, Date.now());
            }
            
            return {
                success: true,
                result: integratedResult,
                taskAnalysis,
                subtasks: subtasks.length,
                executionTime: Date.now()
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÂàÜËß£‰ªªÂä°
     */
    async decomposeTask(parameters, strategy) {
        try {
            const { task } = parameters;
            
            if (!task) {
                throw new Error('Task is required');
            }
            
            const subtasks = [];
            
            // Âü∫‰∫é‰ªªÂä°Á±ªÂûãÂàÜËß£
            if (task.type === 'sequence_analysis') {
                subtasks.push(
                    { type: 'data_retrieval', agent: 'data', priority: 'high' },
                    { type: 'sequence_processing', agent: 'analysis', priority: 'high' },
                    { type: 'result_formatting', agent: 'data', priority: 'low' }
                );
            } else if (task.type === 'external_search') {
                subtasks.push(
                    { type: 'api_call', agent: 'external', priority: 'high' },
                    { type: 'result_processing', agent: 'analysis', priority: 'medium' },
                    { type: 'data_storage', agent: 'data', priority: 'low' }
                );
            } else if (task.type === 'plugin_execution') {
                subtasks.push(
                    { type: 'plugin_validation', agent: 'plugin', priority: 'high' },
                    { type: 'plugin_execution', agent: 'plugin', priority: 'high' },
                    { type: 'result_integration', agent: 'coordinator', priority: 'medium' }
                );
            } else {
                // ÈÄöÁî®‰ªªÂä°ÂàÜËß£
                subtasks.push(
                    { type: 'task_analysis', agent: 'coordinator', priority: 'high' },
                    { type: 'execution', agent: 'auto', priority: 'high' },
                    { type: 'result_validation', agent: 'coordinator', priority: 'medium' }
                );
            }
            
            return {
                success: true,
                subtasks: subtasks.map((subtask, index) => ({
                    id: `subtask_${index}`,
                    ...subtask,
                    dependencies: this.getDependencies(subtask, subtasks, index)
                }))
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Êï¥ÂêàÁªìÊûú
     */
    async integrateResults(parameters, strategy) {
        try {
            const { results } = parameters;
            
            if (!results || !Array.isArray(results)) {
                throw new Error('Results array is required');
            }
            
            // Êåâ‰ºòÂÖàÁ∫ßÊéíÂ∫èÁªìÊûú
            const sortedResults = results.sort((a, b) => b.priority - a.priority);
            
            // Êï¥ÂêàÁªìÊûú
            const integratedResult = {
                success: true,
                data: {},
                metadata: {
                    totalResults: results.length,
                    successfulResults: results.filter(r => r.success).length,
                    failedResults: results.filter(r => !r.success).length,
                    integrationTime: Date.now()
                }
            };
            
            // ÂêàÂπ∂Êï∞ÊçÆ
            results.forEach(result => {
                if (result.success && result.data) {
                    Object.assign(integratedResult.data, result.data);
                }
            });
            
            // Â§ÑÁêÜÈîôËØØ
            const errors = results.filter(r => !r.success).map(r => r.error);
            if (errors.length > 0) {
                integratedResult.warnings = errors;
            }
            
            return {
                success: true,
                integratedResult
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÂàõÂª∫Â∑•‰ΩúÊµÅ
     */
    async createWorkflow(parameters, strategy) {
        try {
            const { name, steps, dependencies = [] } = parameters;
            
            if (!name || !steps) {
                throw new Error('Workflow name and steps are required');
            }
            
            const workflow = await this.workflowEngine.createWorkflow(name, steps, dependencies);
            
            return {
                success: true,
                workflow: {
                    id: workflow.id,
                    name: workflow.name,
                    steps: workflow.steps,
                    status: workflow.status
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÊâßË°åÂ∑•‰ΩúÊµÅ
     */
    async executeWorkflow(parameters, strategy) {
        try {
            const { workflowId, parameters: workflowParams = {} } = parameters;
            
            if (!workflowId) {
                throw new Error('Workflow ID is required');
            }
            
            const result = await this.workflowEngine.executeWorkflow(workflowId, workflowParams);
            
            return {
                success: true,
                result: result,
                workflowId
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Ëé∑ÂèñÂ∑•‰ΩúÊµÅÁä∂ÊÄÅ
     */
    async getWorkflowStatus(parameters, strategy) {
        try {
            const { workflowId } = parameters;
            
            if (!workflowId) {
                throw new Error('Workflow ID is required');
            }
            
            const status = await this.workflowEngine.getWorkflowStatus(workflowId);
            
            return {
                success: true,
                status: status
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÂàÜÈÖç‰ªªÂä°ÁªôÊô∫ËÉΩ‰Ωì
     */
    async assignTaskToAgent(parameters, strategy) {
        try {
            const { task, agentName, priority = 'normal' } = parameters;
            
            if (!task || !agentName) {
                throw new Error('Task and agent name are required');
            }
            
            const agent = this.multiAgentSystem.getAgent(agentName);
            if (!agent) {
                throw new Error(`Agent not found: ${agentName}`);
            }
            
            const result = await agent.executeFunction(task.type, task.parameters, {
                priority,
                timeout: task.timeout || 15000
            });
            
            return {
                success: true,
                result: result,
                agent: agentName,
                task: task.type
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Ëé∑ÂèñÊô∫ËÉΩ‰ΩìÁä∂ÊÄÅ
     */
    async getAgentStatus(parameters, strategy) {
        try {
            const { agentName } = parameters;
            
            if (!agentName) {
                throw new Error('Agent name is required');
            }
            
            const agent = this.multiAgentSystem.getAgent(agentName);
            if (!agent) {
                throw new Error(`Agent not found: ${agentName}`);
            }
            
            const status = await agent.healthCheck();
            
            return {
                success: true,
                status: status
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Ë¥üËΩΩÂùáË°°
     */
    async balanceLoad(parameters, strategy) {
        try {
            const { taskType } = parameters;
            
            // Ëé∑ÂèñÊâÄÊúâÊô∫ËÉΩ‰ΩìÁä∂ÊÄÅ
            const agentStatuses = [];
            for (const [name, agent] of this.multiAgentSystem.getAllAgents()) {
                const status = await agent.healthCheck();
                agentStatuses.push({ name, status });
            }
            
            // ÈÄâÊã©Ë¥üËΩΩÊúÄ‰ΩéÁöÑÊô∫ËÉΩ‰Ωì
            const availableAgents = agentStatuses.filter(agent => 
                agent.status.initialized && agent.status.status === 'ready'
            );
            
            if (availableAgents.length === 0) {
                throw new Error('No available agents');
            }
            
            // Âü∫‰∫é‰ªªÂä°Á±ªÂûãÂíåÊô∫ËÉΩ‰ΩìËÉΩÂäõÈÄâÊã©
            const bestAgent = this.selectBestAgent(taskType, availableAgents);
            
            return {
                success: true,
                selectedAgent: bestAgent.name,
                reason: bestAgent.reason,
                alternatives: availableAgents.map(a => a.name)
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Â§ÑÁêÜÈîôËØØ
     */
    async handleError(parameters, strategy) {
        try {
            const { error, context, retryCount = 0 } = parameters;
            
            if (!error) {
                throw new Error('Error details are required');
            }
            
            // ÂàÜÊûêÈîôËØØÁ±ªÂûã
            const errorAnalysis = this.analyzeError(error, context);
            
            // ÈÄâÊã©ÊÅ¢Â§çÁ≠ñÁï•
            const recoveryStrategy = this.selectRecoveryStrategy(errorAnalysis, retryCount);
            
            // ÊâßË°åÊÅ¢Â§ç
            const recoveryResult = await this.executeRecoveryStrategy(recoveryStrategy, context);
            
            return {
                success: true,
                errorAnalysis,
                recoveryStrategy: recoveryStrategy.type,
                recoveryResult
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÈáçËØïÂ§±Ë¥•‰ªªÂä°
     */
    async retryFailedTask(parameters, strategy) {
        try {
            const { task, maxRetries = 3, backoffDelay = 1000 } = parameters;
            
            if (!task) {
                throw new Error('Task is required');
            }
            
            let lastError = null;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const result = await this.executeTask(task);
                    return {
                        success: true,
                        result: result,
                        attempts: attempt
                    };
                } catch (error) {
                    lastError = error;
                    if (attempt < maxRetries) {
                        await this.delay(backoffDelay * attempt);
                    }
                }
            }
            
            throw lastError;
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÂõûÈÄÄÁ≠ñÁï•
     */
    async fallbackStrategy(parameters, strategy) {
        try {
            const { primaryTask, fallbackTasks } = parameters;
            
            if (!primaryTask || !fallbackTasks) {
                throw new Error('Primary task and fallback tasks are required');
            }
            
            // Â∞ùËØï‰∏ªË¶Å‰ªªÂä°
            try {
                const result = await this.executeTask(primaryTask);
                return {
                    success: true,
                    result: result,
                    strategy: 'primary'
                };
            } catch (error) {
                // Â∞ùËØïÂõûÈÄÄ‰ªªÂä°
                for (const fallbackTask of fallbackTasks) {
                    try {
                        const result = await this.executeTask(fallbackTask);
                        return {
                            success: true,
                            result: result,
                            strategy: 'fallback',
                            fallbackTask: fallbackTask.type
                        };
                    } catch (fallbackError) {
                        console.warn(`Fallback task failed: ${fallbackError.message}`);
                    }
                }
                
                throw new Error('All tasks failed');
            }
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ‰ºòÂåñÊâßË°å
     */
    async optimizeExecution(parameters, strategy) {
        try {
            const { task, optimizationLevel = 'medium' } = parameters;
            
            if (!task) {
                throw new Error('Task is required');
            }
            
            // Ëé∑ÂèñËÆ∞ÂøÜ‰∏ä‰∏ãÊñá
            const memoryContext = this.memorySystem ? 
                await this.memorySystem.retrieveMemoryContext(task.type, task.parameters, {}) :
                this.memorySystem.getEmptyMemoryContext();
            
            // ‰ºòÂåñÂèÇÊï∞
            const optimizedParameters = this.memorySystem.optimizeParameters(
                task.type, task.parameters, memoryContext
            );
            
            // ÈÄâÊã©ÊâßË°åË∑ØÂæÑ
            const executionPath = this.memorySystem.selectExecutionPath(
                task.type, optimizedParameters, memoryContext
            );
            
            return {
                success: true,
                optimization: {
                    originalParameters: task.parameters,
                    optimizedParameters,
                    executionPath,
                    optimizationLevel
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * ÁºìÂ≠òÁ≠ñÁï•
     */
    async cacheStrategy(parameters, strategy) {
        try {
            const { task, cacheKey, ttl = 300000 } = parameters;
            
            if (!task || !cacheKey) {
                throw new Error('Task and cache key are required');
            }
            
            // Ê£ÄÊü•ÁºìÂ≠ò
            const cachedResult = this.getCachedResult(cacheKey);
            if (cachedResult) {
                return {
                    success: true,
                    result: cachedResult,
                    source: 'cache'
                };
            }
            
            // ÊâßË°å‰ªªÂä°
            const result = await this.executeTask(task);
            
            // ÁºìÂ≠òÁªìÊûú
            this.cacheResult(cacheKey, result, ttl);
            
            return {
                success: true,
                result: result,
                source: 'execution'
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Âπ∂Ë°åÊâßË°å
     */
    async parallelExecution(parameters, strategy) {
        try {
            const { tasks, maxConcurrency = 5 } = parameters;
            
            if (!tasks || !Array.isArray(tasks)) {
                throw new Error('Tasks array is required');
            }
            
            // ÂàÜÁªÑ‰ªªÂä°
            const taskGroups = this.groupTasksForParallelExecution(tasks, maxConcurrency);
            
            // Âπ∂Ë°åÊâßË°å
            const results = [];
            for (const group of taskGroups) {
                const groupResults = await Promise.allSettled(
                    group.map(task => this.executeTask(task))
                );
                results.push(...groupResults);
            }
            
            // Â§ÑÁêÜÁªìÊûú
            const successfulResults = results
                .filter(r => r.status === 'fulfilled')
                .map(r => r.value);
            
            const failedResults = results
                .filter(r => r.status === 'rejected')
                .map(r => r.reason);
            
            return {
                success: true,
                results: {
                    successful: successfulResults,
                    failed: failedResults,
                    total: results.length,
                    successRate: successfulResults.length / results.length
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    // ËæÖÂä©ÊñπÊ≥ï
    
    /**
     * ÂàÜÊûê‰ªªÂä°
     */
    async analyzeTask(task) {
        return {
            type: task.type,
            complexity: this.assessComplexity(task),
            requirements: this.extractRequirements(task),
            estimatedTime: this.estimateExecutionTime(task)
        };
    }
    
    /**
     * ËØÑ‰º∞Â§çÊùÇÂ∫¶
     */
    assessComplexity(task) {
        // Âü∫‰∫é‰ªªÂä°Á±ªÂûãÂíåÂèÇÊï∞ËØÑ‰º∞Â§çÊùÇÂ∫¶
        const complexityFactors = {
            dataSize: task.parameters?.dataSize || 1,
            operationCount: task.parameters?.operationCount || 1,
            externalCalls: task.type.includes('external') ? 2 : 1
        };
        
        return Object.values(complexityFactors).reduce((sum, factor) => sum + factor, 0);
    }
    
    /**
     * ÊèêÂèñÈúÄÊ±Ç
     */
    extractRequirements(task) {
        return {
            agents: this.getRequiredAgents(task),
            resources: this.getRequiredResources(task),
            permissions: this.getRequiredPermissions(task)
        };
    }
    
    /**
     * ‰º∞ÁÆóÊâßË°åÊó∂Èó¥
     */
    estimateExecutionTime(task) {
        const baseTime = 1000; // Âü∫Á°ÄÊó∂Èó¥1Áßí
        const complexity = this.assessComplexity(task);
        return baseTime * complexity;
    }
    
    /**
     * Ëé∑Âèñ‰æùËµñÂÖ≥Á≥ª
     */
    getDependencies(subtask, allSubtasks, currentIndex) {
        const dependencies = [];
        
        // Âü∫‰∫é‰ªªÂä°Á±ªÂûãÁ°ÆÂÆö‰æùËµñÂÖ≥Á≥ª
        if (subtask.type === 'result_processing') {
            dependencies.push('data_retrieval');
        } else if (subtask.type === 'result_integration') {
            dependencies.push('execution');
        }
        
        return dependencies;
    }
    
    /**
     * ÂàÜÈÖçÂ≠ê‰ªªÂä°ÁªôÊô∫ËÉΩ‰Ωì
     */
    async assignSubtasksToAgents(subtasks) {
        const assignments = [];
        
        for (const subtask of subtasks) {
            const agentName = subtask.agent === 'auto' ? 
                await this.selectBestAgent(subtask.type) : subtask.agent;
            
            assignments.push({
                subtask,
                agent: agentName,
                priority: subtask.priority
            });
        }
        
        return assignments;
    }
    
    /**
     * ÊâßË°åÂ≠ê‰ªªÂä°
     */
    async executeSubtasks(assignments, timeout) {
        const results = [];
        
        for (const assignment of assignments) {
            try {
                const result = await Promise.race([
                    this.assignTaskToAgent({
                        task: assignment.subtask,
                        agentName: assignment.agent,
                        priority: assignment.priority
                    }),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), timeout)
                    )
                ]);
                
                results.push(result);
            } catch (error) {
                results.push({
                    success: false,
                    error: error.message,
                    subtask: assignment.subtask.type,
                    agent: assignment.agent
                });
            }
        }
        
        return results;
    }
    
    /**
     * ÈÄâÊã©ÊúÄ‰Ω≥Êô∫ËÉΩ‰Ωì
     */
    selectBestAgent(taskType, availableAgents) {
        // Âü∫‰∫é‰ªªÂä°Á±ªÂûãÂíåÊô∫ËÉΩ‰ΩìËÉΩÂäõÈÄâÊã©ÊúÄ‰Ω≥Êô∫ËÉΩ‰Ωì
        const agentCapabilities = {
            'data_retrieval': ['data'],
            'sequence_processing': ['analysis'],
            'api_call': ['external'],
            'plugin_execution': ['plugin'],
            'navigation': ['navigation']
        };
        
        const preferredAgents = agentCapabilities[taskType] || ['coordinator'];
        
        for (const preferredAgent of preferredAgents) {
            const agent = availableAgents.find(a => a.name === preferredAgent);
            if (agent) {
                return { name: agent.name, reason: `Preferred agent for ${taskType}` };
            }
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÈ¶ñÈÄâÊô∫ËÉΩ‰ΩìÔºåÈÄâÊã©Ë¥üËΩΩÊúÄ‰ΩéÁöÑ
        const leastLoadedAgent = availableAgents.reduce((min, agent) => 
            agent.status.performanceStats?.totalExecutions < min.status.performanceStats?.totalExecutions ? agent : min
        );
        
        return { name: leastLoadedAgent.name, reason: 'Least loaded agent' };
    }
    
    /**
     * ÂàÜÊûêÈîôËØØ
     */
    analyzeError(error, context) {
        return {
            type: this.classifyError(error),
            severity: this.assessErrorSeverity(error),
            recoverable: this.isErrorRecoverable(error),
            context: context
        };
    }
    
    /**
     * ÈÄâÊã©ÊÅ¢Â§çÁ≠ñÁï•
     */
    selectRecoveryStrategy(errorAnalysis, retryCount) {
        if (retryCount >= 3) {
            return { type: 'fallback', action: 'use_alternative_method' };
        }
        
        if (errorAnalysis.recoverable) {
            return { type: 'retry', action: 'retry_with_backoff' };
        }
        
        return { type: 'fallback', action: 'use_alternative_method' };
    }
    
    /**
     * ÊâßË°åÊÅ¢Â§çÁ≠ñÁï•
     */
    async executeRecoveryStrategy(strategy, context) {
        switch (strategy.type) {
            case 'retry':
                return await this.retryFailedTask({ task: context.task, maxRetries: 1 });
            case 'fallback':
                return await this.fallbackStrategy({ 
                    primaryTask: context.task, 
                    fallbackTasks: context.fallbackTasks 
                });
            default:
                throw new Error(`Unknown recovery strategy: ${strategy.type}`);
        }
    }
    
    /**
     * ÊâßË°å‰ªªÂä°
     */
    async executeTask(task) {
        const agent = this.multiAgentSystem.getAgent(task.agent);
        if (!agent) {
            throw new Error(`Agent not found: ${task.agent}`);
        }
        
        return await agent.executeFunction(task.type, task.parameters, {});
    }
    
    /**
     * ÂàÜÁªÑ‰ªªÂä°Áî®‰∫éÂπ∂Ë°åÊâßË°å
     */
    groupTasksForParallelExecution(tasks, maxConcurrency) {
        const groups = [];
        for (let i = 0; i < tasks.length; i += maxConcurrency) {
            groups.push(tasks.slice(i, i + maxConcurrency));
        }
        return groups;
    }
    
    /**
     * Âª∂ËøüÂáΩÊï∞
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * ÂàÜÁ±ªÈîôËØØ
     */
    classifyError(error) {
        if (error.message.includes('timeout')) return 'timeout';
        if (error.message.includes('network')) return 'network';
        if (error.message.includes('permission')) return 'permission';
        if (error.message.includes('not found')) return 'not_found';
        return 'unknown';
    }
    
    /**
     * ËØÑ‰º∞ÈîôËØØ‰∏•ÈáçÊÄß
     */
    assessErrorSeverity(error) {
        if (error.message.includes('critical')) return 'critical';
        if (error.message.includes('fatal')) return 'critical';
        if (error.message.includes('timeout')) return 'medium';
        return 'low';
    }
    
    /**
     * Ê£ÄÊü•ÈîôËØØÊòØÂê¶ÂèØÊÅ¢Â§ç
     */
    isErrorRecoverable(error) {
        const nonRecoverableErrors = ['permission', 'not_found', 'invalid_parameter'];
        const errorType = this.classifyError(error);
        return !nonRecoverableErrors.includes(errorType);
    }
}

/**
 * Â∑•‰ΩúÊµÅÂºïÊìé
 */
class WorkflowEngine {
    constructor(coordinatorAgent) {
        this.coordinatorAgent = coordinatorAgent;
        this.workflows = new Map();
        this.executions = new Map();
    }
    
    /**
     * ÂàõÂª∫Â∑•‰ΩúÊµÅ
     */
    async createWorkflow(name, steps, dependencies) {
        const workflowId = `workflow_${Date.now()}`;
        const workflow = {
            id: workflowId,
            name,
            steps,
            dependencies,
            status: 'created',
            createdAt: Date.now()
        };
        
        this.workflows.set(workflowId, workflow);
        return workflow;
    }
    
    /**
     * ÊâßË°åÂ∑•‰ΩúÊµÅ
     */
    async executeWorkflow(workflowId, parameters) {
        const workflow = this.workflows.get(workflowId);
        if (!workflow) {
            throw new Error(`Workflow not found: ${workflowId}`);
        }
        
        const executionId = `exec_${Date.now()}`;
        const execution = {
            id: executionId,
            workflowId,
            status: 'running',
            startTime: Date.now(),
            results: []
        };
        
        this.executions.set(executionId, execution);
        
        try {
            // Êåâ‰æùËµñÂÖ≥Á≥ªÊéíÂ∫èÊ≠•È™§
            const sortedSteps = this.topologicalSort(workflow.steps, workflow.dependencies);
            
            // ÊâßË°åÊ≠•È™§
            for (const step of sortedSteps) {
                const result = await this.executeStep(step, parameters);
                execution.results.push(result);
            }
            
            execution.status = 'completed';
            execution.endTime = Date.now();
            
            return {
                success: true,
                results: execution.results,
                executionTime: execution.endTime - execution.startTime
            };
            
        } catch (error) {
            execution.status = 'failed';
            execution.error = error.message;
            throw error;
        }
    }
    
    /**
     * Ëé∑ÂèñÂ∑•‰ΩúÊµÅÁä∂ÊÄÅ
     */
    async getWorkflowStatus(workflowId) {
        const workflow = this.workflows.get(workflowId);
        if (!workflow) {
            throw new Error(`Workflow not found: ${workflowId}`);
        }
        
        return {
            id: workflow.id,
            name: workflow.name,
            status: workflow.status,
            steps: workflow.steps.length,
            createdAt: workflow.createdAt
        };
    }
    
    /**
     * ÊâßË°åÊ≠•È™§
     */
    async executeStep(step, parameters) {
        const stepParameters = { ...parameters, ...step.parameters };
        return await this.coordinatorAgent.executeFunction(step.type, stepParameters, {});
    }
    
    /**
     * ÊãìÊâëÊéíÂ∫è
     */
    topologicalSort(steps, dependencies) {
        // ÁÆÄÂçïÁöÑÊãìÊâëÊéíÂ∫èÂÆûÁé∞
        const sorted = [];
        const visited = new Set();
        
        const visit = (step) => {
            if (visited.has(step.id)) return;
            visited.add(step.id);
            
            const stepDeps = dependencies.filter(d => d.to === step.id);
            for (const dep of stepDeps) {
                const depStep = steps.find(s => s.id === dep.from);
                if (depStep) visit(depStep);
            }
            
            sorted.push(step);
        };
        
        for (const step of steps) {
            visit(step);
        }
        
        return sorted;
    }
}

// ÂØºÂá∫Êô∫ËÉΩ‰Ωì
window.CoordinatorAgent = CoordinatorAgent;
window.WorkflowEngine = WorkflowEngine; 